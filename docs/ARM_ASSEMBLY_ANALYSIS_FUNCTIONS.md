# ARM Assembly Analysis: Function-Based Mersenne Factors

## Overview

This document analyzes the ARM64 assembly code generated by the FasterBASIC QBE compiler for the function-based implementation of the Mersenne factors program. The code demonstrates excellent optimization characteristics including native function calls, efficient integer arithmetic, and minimal register spilling.

## Generated Functions

### 1. ModularPower Function

**BASIC Source:**
```basic
FUNCTION ModularPower&(basenum AS LONG, exponent AS LONG, m AS LONG) AS LONG
    LOCAL res&
    LOCAL b&
    LOCAL e&
    LOCAL bit&
    
    LET res& = 1
    LET b& = basenum MOD m
    LET e& = exponent
    
    WHILE e& > 0
        LET bit& = e& MOD 2
        IF bit& = 1 THEN
            LET res& = (res& * b&) MOD m
        END IF
        LET b& = (b& * b&) MOD m
        LET e& = e& / 2
    WEND
    
    RETURN res&
END FUNCTION
```

**Generated ARM Assembly:**
```asm
_ModularPower:
	hint	#34                       # BTI (Branch Target Identification)
	stp	x29, x30, [sp, -16]!      # Save frame pointer & link register
	mov	x29, sp                    # Set up frame pointer
	
	# Initialize: b = basenum MOD m
	sdiv	x17, x0, x2               # x17 = basenum / m
	msub	x3, x17, x2, x0           # x3 = basenum - (x17 * m) = basenum MOD m
	
	mov	x0, #1                     # res = 1
	
L24:  # WHILE loop start
	cmp	x1, #0                     # Compare e with 0
	ble	L28                        # If e <= 0, exit loop
	
	# bit = e MOD 2
	mov	x4, #2
	sdiv	x17, x1, x4
	msub	x4, x17, x4, x1           # x4 = e MOD 2
	
	# IF bit = 1 THEN
	cmp	x4, #1
	bne	L27
	
	# res = (res * b) MOD m
	mul	x0, x3, x0                 # x0 = res * b
	sdiv	x17, x0, x2
	msub	x0, x17, x2, x0           # x0 = (res * b) MOD m
	
L27:
	# b = (b * b) MOD m
	mul	x3, x3, x3                 # x3 = b * b
	sdiv	x17, x3, x2
	msub	x3, x17, x2, x3           # x3 = (b * b) MOD m
	
	# e = e / 2 (using floating point - could be optimized to shift)
	scvtf	d0, x1                   # Convert e to double
	adrp	x1, "Lfp3"@page
	add	x1, x1, "Lfp3"@pageoff
	ldr	d1, [x1]                  # Load 2.0
	fdiv	d0, d0, d1                # d0 = e / 2.0
	fcvtzs	x1, d0                  # Convert back to integer
	
	b	L24                         # Loop back
	
L28:
	ldp	x29, x30, [sp], 16        # Restore frame & link register
	ret
```

**Analysis:**

**Strengths:**
- **Minimal stack usage**: Only 16 bytes (frame pointer + link register)
- **Register allocation**: 
  - `x0` = result
  - `x1` = exponent counter
  - `x2` = modulus (preserved throughout)
  - `x3` = base value
  - `x17` = scratch register for division
- **No LOCAL variable spilling**: All LOCAL variables kept in registers!
- **Efficient modulo**: Uses `sdiv`/`msub` pattern (quotient/multiply/subtract)
- **Native function convention**: Standard ARM64 calling convention

**Optimization Opportunity:**
- The division by 2 could be replaced with a right shift: `lsr x1, x1, #1` would be faster than the float conversion

### 2. IsPrime Function

**Generated ARM Assembly:**
```asm
_IsPrime:
	hint	#34
	stp	x29, x30, [sp, -32]!      # Save frame + link register + 16 bytes
	mov	x29, sp
	str	x19, [x29, 24]            # Save x19 (callee-saved register)
	
	# Early exit checks
	cmp	x0, #2
	blt	L43                        # if n < 2: return 0
	cmp	x0, #2
	beq	L42                        # if n == 2: return 1
	cmp	x0, #3
	beq	L41                        # if n == 3: return 1
	
	# Check if even
	mov	x19, x0                    # Save n in x19
	mov	x0, #2
	sdiv	x17, x19, x0
	msub	x0, x17, x0, x19          # x0 = n MOD 2
	cmp	x0, #0
	beq	L40                        # if even: return 0
	
	# Trial division loop
	scvtf	d0, x19                  # Convert n to double
	bl	_basic_sqrt                # Call sqrt(n)
	bl	_basic_int                 # Call int(sqrt(n))
	mov	w1, w0                     # w1 = sqrtmax
	mov	x0, x19                    # Restore n
	sxtw	x1, w1                    # Sign-extend to 64-bit
	mov	x2, #1
	add	x2, x1, x2                 # x2 = sqrtmax + 1
	mov	x1, #3                     # divisor = 3
	
L35:  # Trial division loop
	cmp	x1, x2                     # Compare divisor with limit
	bgt	L39                        # If divisor > limit: return 1 (prime)
	
	sdiv	x17, x0, x1
	msub	x3, x17, x1, x0           # x3 = n MOD divisor
	cmp	x3, #0
	beq	L38                        # If divisible: return 0
	
	mov	x3, #2
	add	x1, x1, x3                 # divisor += 2 (skip evens)
	b	L35
	
L38:
	mov	x0, #0                     # Not prime
	b	L44
L39:
	mov	x0, #1                     # Prime
	b	L44
L40:
	mov	x0, #0                     # Even (not prime)
	b	L44
L41:
	mov	x0, #1                     # 3 is prime
	b	L44
L42:
	mov	x0, #1                     # 2 is prime
	b	L44
L43:
	mov	x0, #0                     # < 2 (not prime)
L44:
	ldr	x19, [x29, 24]            # Restore x19
	ldp	x29, x30, [sp], 32
	ret
```

**Analysis:**

**Strengths:**
- **Smart early exits**: Handles 2, 3, and even numbers before main loop
- **Register preservation**: Uses callee-saved x19 for the value of n
- **Tight trial division loop**: Only 7 instructions per iteration
- **Efficient odd-only checking**: Increments by 2 to skip even divisors
- **Multiple exit paths**: Each with appropriate return value

**Stack Usage:**
- 32 bytes: frame pointer, link register, and saved x19
- Minimal compared to potential LOCAL variable storage

### 3. Main Function

**Key Assembly Patterns:**

```asm
_main:
	hint	#34
	stp	x29, x30, [sp, -48]!      # Larger stack frame for main
	mov	x29, sp
	str	x19, [x29, 40]            # Save callee-saved registers
	str	x20, [x29, 32]
	str	d8, [x29, 24]
	str	d9, [x29, 16]
	
	bl	_basic_runtime_init       # Initialize runtime
	
	# ... main loop ...
	
	# Call IsPrime(q)
	mov	x0, x20                    # Pass q in x0
	bl	_IsPrime                   # Native function call
	cmp	x0, #1                     # Check return value
	beq	L11
	
	# Call ModularPower(2, 929, q)
	mov	x1, #929
	mov	x0, #2
	bl	_ModularPower              # Native function call
	cmp	x0, #1
	beq	L13
```

**Analysis:**

**Function Call Convention:**
- **Parameters**: Passed in registers x0, x1, x2 (first 3 integer args)
- **Return value**: In x0
- **No stack parameters**: All parameters fit in registers
- **Direct calls**: Uses `bl` (branch with link) for direct function calls
- **No GOSUB stack**: Native ARM calling convention, not BASIC's return stack

## Comparison: Functions vs GOSUB/RETURN

### Function-Based Approach (This Version)

**Pros:**
- ✅ **Native calls**: Uses ARM `bl` instruction and hardware return stack
- ✅ **Register-based parameters**: Fast parameter passing
- ✅ **Minimal overhead**: 1-2 instructions per call/return
- ✅ **Hardware optimization**: CPU branch predictor helps
- ✅ **No dispatch logic**: Direct return via `ret` instruction
- ✅ **Register preservation**: Automatic via ARM ABI

**Stack per call:**
- ModularPower: 16 bytes
- IsPrime: 32 bytes
- Total overhead: ~5-10 cycles per call

### GOSUB/RETURN Approach (Original)

**Pros:**
- ✅ **SSA friendly**: All variables stay as SSA temporaries
- ✅ **Simple codegen**: No function parameter marshaling

**Cons:**
- ❌ **Stack manipulation**: Manual push/pop of return block ID
- ❌ **Dispatch overhead**: Linear search through return blocks (now optimized to sparse)
- ❌ **No hardware support**: Software-only return mechanism
- ❌ **Larger code**: Return dispatch code replicated

**Overhead per GOSUB/RETURN:**
- GOSUB: ~5-10 instructions (push block ID, jump)
- RETURN: 2-10 instructions (pop + sparse jump table lookup)
- Original worst case: 50+ comparisons for programs with many GOSUBs

## Performance Characteristics

### ModularPower Performance

**For M929 (exponent = 929):**
- Loop iterations: ~929 (one per bit)
- Operations per iteration: ~10-15 ARM instructions
- Estimated cycles: ~10,000-15,000 total

**Efficiency:**
- No function call overhead (called once per candidate)
- All arithmetic stays in registers
- Modulo operations optimized by compiler

### IsPrime Performance

**For typical candidate q = 13007:**
- sqrt(13007) ≈ 114
- Trial divisions: ~57 (odd numbers from 3 to 114)
- Instructions per division: ~7
- Estimated cycles: ~400-500 per call

**Efficiency:**
- Early exits save work
- Tight inner loop
- Good cache behavior

## Code Size Analysis

```
Main function:        ~500 instructions
ModularPower:         ~30 instructions
IsPrime:              ~60 instructions
Total:                ~590 instructions

Compare to GOSUB version:
- Similar main loop size
- No return dispatch code (saves ~50+ instructions)
- Added function prologue/epilogue (~10 instructions)
```

**Net result:** Function-based version is slightly **smaller** due to eliminated return dispatch.

## Optimization Observations

### What the Compiler Did Well

1. **Register allocation**: LOCAL variables never spill to stack
2. **Constant propagation**: Immediate values like #1, #2, #929 embedded in code
3. **Loop structure**: Tight loops with minimal branching
4. **Call convention**: Proper ARM64 ABI compliance
5. **Stack discipline**: Minimal frame sizes

### Remaining Optimization Opportunities

1. **Integer division by 2**: Could use `lsr` instead of float conversion
2. **Modulo optimization**: Could use bit masking for powers of 2
3. **Loop unrolling**: IsPrime trial division could check 2 divisors per iteration
4. **Inlining**: ModularPower could be inlined into main (though large)
5. **SIMD**: Could test multiple candidates in parallel (advanced)

## Conclusion

The function-based approach generates **excellent ARM assembly** that:

- Uses native function calls and returns (hardware optimized)
- Keeps all variables in registers (no memory traffic for locals)
- Has minimal per-call overhead (16-32 bytes stack, 2-4 instructions)
- Produces smaller code than GOSUB/RETURN dispatch
- Follows ARM64 ABI conventions (interoperable with C/other languages)
- Demonstrates that the LOCAL variable type bug fix was successful

The generated code is **production quality** and demonstrates that FasterBASIC's QBE backend can generate competitive native code for mathematical algorithms.

---

**Date:** 2024-01-31  
**Program:** `tests/rosetta/mersenne_factors2.bas`  
**Compiler:** FasterBASIC QBE with LOCAL variable type fix  
**Target:** ARM64 (Apple Silicon)  
**Status:** ✅ Verified working, found factor 13007 for M929
## Detailed Code Size Comparison

### Assembly Line Counts

```
GOSUB/RETURN version:  744 lines
Function version:      566 lines
Difference:            -178 lines (-24%)
```

### GOSUB Return Stack Operations

**GOSUB (push return address):**
```asm
	adrp	x0, _return_sp@page       # Load return stack pointer address
	add	x0, x0, _return_sp@pageoff
	ldr	w1, [x0]                   # Load current stack pointer
	sxtw	x2, w1                    # Sign extend to 64-bit
	mov	x0, #4
	mul	x0, x2, x0                 # Calculate offset (sp * 4)
	adrp	x3, _return_stack@page    # Load return stack address
	add	x3, x3, _return_stack@pageoff
	add	x4, x0, x3                 # Calculate target address
	mov	w3, #11                    # Return block ID
	str	w3, [x4]                   # Store return address
	mov	w3, #1
	add	w3, w1, w3                 # Increment stack pointer
	adrp	x4, _return_sp@page
	add	x4, x4, _return_sp@pageoff
	str	w3, [x4]                   # Store updated stack pointer
	# ... then jump to subroutine
```

**Cost: ~15 instructions per GOSUB**

**RETURN (pop and dispatch):**
```asm
	adrp	x0, _return_sp@page       # Load return stack pointer
	add	x0, x0, _return_sp@pageoff
	ldr	w0, [x0]                   # Load stack pointer
	mov	w1, #1
	sub	w1, w0, w1                 # Decrement stack pointer
	adrp	x0, _return_sp@page
	add	x0, x0, _return_sp@pageoff
	str	w1, [x0]                   # Store decremented pointer
	sxtw	x0, w1
	mov	x2, #4
	mul	x0, x0, x2                 # Calculate offset
	adrp	x2, _return_stack@page
	add	x2, x2, _return_stack@pageoff
	add	x0, x0, x2
	ldr	w0, [x0]                   # Load return block ID
	
	# Sparse jump table (after optimization)
	cmp	w0, #11                    # Check against return block 11
	beq	L11_return
	cmp	w0, #28                    # Check against return block 28
	beq	L28_return
	# ... more comparisons for each return block
```

**Cost: ~12 + (2 * N) instructions per RETURN, where N = number of return blocks**

### Function Call Operations

**Function Call:**
```asm
	mov	x0, x20                    # Pass argument 1 in x0
	bl	_IsPrime                   # Call function (1 instruction!)
	cmp	x0, #1                     # Check return value
```

**Cost: 3 instructions total (including argument setup and result check)**

**Function Return:**
```asm
	ret                            # Return (1 instruction!)
```

**Cost: 1 instruction**

### Performance Summary

**Per Subroutine Call:**

| Approach | Call Overhead | Return Overhead | Total | Notes |
|----------|--------------|-----------------|-------|-------|
| GOSUB/RETURN | ~15 instructions | ~12-50 instructions | ~27-65 | Depends on # of return blocks |
| Functions | ~2 instructions | ~1 instruction | ~3 | Native ARM calling convention |

**Speedup: ~9-22× faster per call/return pair**

### Code Density Comparison

The 178-line reduction comes from:
1. **Eliminated return stack management** (~100 lines)
2. **Eliminated sparse jump table** (~50 lines)
3. **Simplified control flow** (~20 lines)
4. **Added function prologues/epilogues** (+10 lines)

**Net savings: ~160 lines of assembly**

## Real-World Performance Impact

For the Mersenne M929 test:
- IsPrime called: ~7 times (until factor found)
- ModularPower called: ~7 times
- Total subroutine calls: ~14

**Estimated cycle savings:**
- GOSUB/RETURN: 14 × 40 instructions = ~560 instructions
- Functions: 14 × 4 instructions = ~56 instructions
- **Savings: ~500 instructions (~1000 cycles on modern ARM)**

This is negligible compared to the mathematical operations (~10,000+ cycles), but demonstrates the efficiency advantage of native calls.

---

**Conclusion:** Functions are not just cleaner code—they generate **significantly smaller and faster** assembly.
