# QBE Backend Bug Report: Register Allocation Corruption in ARM64

## Summary

The QBE ARM64 backend generates incorrect code that corrupts array access values after control flow merges (WHILE loops with nested IF statements). The generated QBE IL is correct, but the ARM64 register allocator/emitter assigns physical registers in a way that causes values to be clobbered across basic block boundaries.

**Expected behavior**: Array element `arr(1)` should contain value `10`  
**Actual behavior**: Array element `arr(1)` contains garbage value `1027082214` (or other random values)

## Environment

- **Architecture**: ARM64 (Apple Silicon M-series)
- **QBE Version**: Embedded fork (based on upstream QBE)
- **Operating System**: macOS
- **Compiler**: Clang/LLVM (Apple)

## Minimal Reproducer

### Source Program (test_array_after_while_if.bas)

```basic
REM Minimal test case for array access bug after WHILE with nested IF

DIM arr(100) AS INT
DIM i AS INT

REM Initialize array
i = 1
WHILE i <= 10
    arr(i) = i * 10
    i = i + 1
WEND

REM Simple IF statement
IF arr(1) = 10 THEN
    PRINT "arr(1) is correct: "; arr(1)
END IF

REM This should work but shows corrupted value
PRINT "After IF, arr(1) = "; arr(1)
PRINT "arr(2) = "; arr(2)
PRINT "arr(3) = "; arr(3)
```

### Expected Output
```
arr(1) is correct: 10
After IF, arr(1) = 10
arr(2) = 20
arr(3) = 30
```

### Actual Output
```
arr(1) is correct: 1027082214
After IF, arr(1) = 1027082214
arr(2) = 20
arr(3) = 30
```

Note: `arr(2)` and `arr(3)` are correct, but `arr(1)` is corrupted.

## QBE IL (Relevant Section)

The generated IL for the problematic array access after the WHILE loop is **correct**:

```qbe
@block_3
    # Block 3 (After WHILE)
    %t42 =l copy 1
    %t43 =l copy %arr_arr           # Copy array descriptor pointer
    # Array access arr with bounds check
    %t44 =l add %t43, 8             # Get lower bound field offset
    %t45 =l loadl %t44              # Load lower bound
    %t46 =l add %t43, 16            # Get upper bound field offset
    %t47 =l loadl %t46              # Load upper bound
    %t48 =l extsw %t42              # Sign-extend index to 64-bit
    %t49 =w csgel %t48, %t45        # Check index >= lower bound
    %t50 =w cslel %t48, %t47        # Check index <= upper bound
    %t51 =w and %t49, %t50          # Combine checks
    jnz %t51, @L2, @L3
@L3
    call $basic_array_bounds_error(l %t48, l %t45, l %t47)
@L2
    %t52 =l sub %t48, %t45          # Compute adjusted index
    %t53 =l add %t43, 40            # Get element size field offset
    %t54 =l loadl %t53              # Load element size (4 bytes)
    %t55 =l mul %t52, %t54          # Compute byte offset
    %t56 =l copy %arr_arr           # Re-copy array descriptor
    %t57 =l loadl %t56              # Load data pointer
    %t58 =l add %t57, %t55          # Add offset to data pointer
    %t59 =w loadw %t58              # Load array element
```

**Analysis of IL**:
- Line `%t43 =l copy %arr_arr` correctly copies the array descriptor pointer
- Bounds checks are properly performed
- Offset computation is correct: `(index - lower_bound) * element_size`
- Data pointer is loaded from the descriptor at offset 0
- Final load uses `data_pointer + byte_offset`

This IL is semantically correct and should work.

## ARM64 Assembly (Problematic Section)

The ARM64 assembly generated by QBE shows register allocation issues:

```asm
L7:
	mov	x0, x21                 # x21 contains array data pointer
	mov	x2, x25                 # x25 contains upper bound
	cmp	x24, #1                 # Compare lower bound (x24) with 1
	cset	w20, le
	cmp	x2, #1
	cset	w23, ge
	and	w1, w20, w23
	cmp	w1, #0
	bne	L10
	mov	x26, x2
	mov	x1, x24
	mov	x19, x0                 # Save x0 to x19
	mov	x0, #1
	bl	_basic_array_bounds_error
	mov	x0, x19                 # Restore from x19
	b	L11
L10:
	mov	x26, x2
L11:
	mov	x1, #1                  # Index = 1
	sub	x19, x1, x24            # x19 = adjusted_index (1 - lower_bound)
	madd	x1, x19, x22, x0        # x1 = x0 + (x19 * x22)
                                    # PROBLEM: x0 should be data pointer
                                    # but it has been clobbered!
	ldr	w1, [x1]                # Load from wrong address
	sxtw	x1, w1
	cmp	x1, #10
	bne	L16
```

**Problem Identified**:
1. At label `L7`, register `x0` should contain the array data pointer (from `x21`)
2. The code path through `L10` to `L11` preserves `x0` in this case
3. However, at `L11`, the `sub` instruction reuses `x19` for the adjusted index
4. The `madd` instruction computes the address: `x1 = x0 + (x19 * x22)`
5. **But `x0` at this point does NOT reliably contain the data pointer** due to register reuse across control flow paths

The register allocator has assigned physical registers in a way that causes `x0` (or the register holding the data pointer) to be clobbered/reused before the actual array load.

## Root Cause

The bug is in the QBE ARM64 backend's register allocation. Specifically:

1. **Register allocation across PHI nodes/control-flow merges**: The allocator does not properly preserve values that are live across basic block boundaries when there are multiple paths converging (WHILE loop exit + IF/ELSE merge).

2. **Incorrect liveness analysis**: The register allocator appears to believe that the data pointer value is dead or can be reused, when in fact it is still needed for the subsequent array access.

3. **Not specific to MADD fusion**: Disabling the MADD peephole optimization does NOT fix this bug. The issue persists with separate MUL + ADD instructions, indicating the problem is in register assignment, not instruction selection.

## Evidence That This Is Not an IL Bug

1. The emitted QBE IL explicitly copies `%arr_arr` multiple times and loads the data pointer immediately before use
2. Bounds checking IL is correct and complete
3. Offset computation follows the standard formula
4. The same IL pattern works correctly for `arr(2)` and `arr(3)`, but fails for `arr(1)` which comes right after the control flow merge

## Attempted Workarounds

We attempted several codegen-level workarounds, none of which reliably fixed the issue:

1. **Explicit copy of array descriptor**: Inserted `%descPtr =l copy %arr_<name>` into a fresh temporary before each use
2. **Reload after bounds check**: Re-loaded the array descriptor and data pointer after control flow merges
3. **Unique temporaries**: Used distinct temporary names to try to prevent register reuse

These workarounds sometimes changed which values got corrupted, but did not eliminate the bug, confirming that the issue is in the backend register allocator, not in our IL generation logic.

## Steps to Reproduce

1. Compile the QBE IL file with QBE for ARM64:
   ```bash
   qbe -t arm64 test_minimal.qbe > test_minimal.s
   ```

2. Link and run (requires runtime library):
   ```bash
   clang test_minimal.s -o test_minimal [runtime libraries]
   ./test_minimal
   ```

3. Observe incorrect output for `arr(1)`

## Additional Test Cases

This bug affects multiple tests in our suite:
- `test_primes_sieve.bas` - Sieve of Eratosthenes (crashes)
- `test_array_after_while_if.bas` - Minimal reproducer (wrong values)
- Any code with array accesses after WHILE loops containing IF statements

## Recommendation

This appears to be a fundamental bug in QBE's ARM64 register allocator related to liveness analysis and register assignment across control flow merges. The issue needs to be fixed in the QBE backend itself, as it cannot be worked around from the IL generation side without massive and fragile changes.

## Files Included

- `test_array_after_while_if.bas` - Minimal BASIC source program
- `test_minimal.qbe` - Generated QBE IL (correct)
- `test_minimal.s` - Generated ARM64 assembly (incorrect register allocation)
- This bug report

## Contact

Generated by FasterBASIC compiler investigation.
Date: 2025-01-31