    # Generated by FasterBASIC QBE Code Generator
    # Target: QBE IL (SSA format)
    # 
    # External runtime functions from libbasic_runtime.a

    # === MAIN FUNCTION ===

export function w $main() {
@start
    # Initialize runtime
    call $basic_runtime_init()

    # Variable declarations
    %var_I_INT =l copy 0
    %var_I_ =l copy 0
    %arr_Z_INT =l alloc8 64
    storel 0, %arr_Z_INT
    %t0 =l add %arr_Z_INT, 8
    storel 0, %t0
    %t1 =l add %arr_Z_INT, 16
    storel -1, %t1
    %t2 =l add %arr_Z_INT, 24
    storel 0, %t2
    %t3 =l add %arr_Z_INT, 32
    storew 0, %t3
    # Array descriptor Z_INT allocated (40 bytes)
    %arr_Y_INT =l alloc8 64
    storel 0, %arr_Y_INT
    %t4 =l add %arr_Y_INT, 8
    storel 0, %t4
    %t5 =l add %arr_Y_INT, 16
    storel -1, %t5
    %t6 =l add %arr_Y_INT, 24
    storel 0, %t6
    %t7 =l add %arr_Y_INT, 32
    storew 0, %t7
    # Array descriptor Y_INT allocated (40 bytes)
    %arr_F_STRING =l alloc8 64
    storel 0, %arr_F_STRING
    %t8 =l add %arr_F_STRING, 8
    storel 0, %t8
    %t9 =l add %arr_F_STRING, 16
    storel -1, %t9
    %t10 =l add %arr_F_STRING, 24
    storel 0, %t10
    %t11 =l add %arr_F_STRING, 32
    storew 0, %t11
    # Array descriptor F_STRING allocated (40 bytes)
    %arr_C_STRING =l alloc8 64
    storel 0, %arr_C_STRING
    %t12 =l add %arr_C_STRING, 8
    storel 0, %t12
    %t13 =l add %arr_C_STRING, 16
    storel -1, %t13
    %t14 =l add %arr_C_STRING, 24
    storel 0, %t14
    %t15 =l add %arr_C_STRING, 32
    storew 0, %t15
    # Array descriptor C_STRING allocated (40 bytes)
    %arr_X_INT =l alloc8 64
    storel 0, %arr_X_INT
    %t16 =l add %arr_X_INT, 8
    storel 0, %t16
    %t17 =l add %arr_X_INT, 16
    storel -1, %t17
    %t18 =l add %arr_X_INT, 24
    storel 0, %t18
    %t19 =l add %arr_X_INT, 32
    storew 0, %t19
    # Array descriptor X_INT allocated (40 bytes)
    %arr_D_INT =l alloc8 64
    storel 0, %arr_D_INT
    %t20 =l add %arr_D_INT, 8
    storel 0, %t20
    %t21 =l add %arr_D_INT, 16
    storel -1, %t21
    %t22 =l add %arr_D_INT, 24
    storel 0, %t22
    %t23 =l add %arr_D_INT, 32
    storew 0, %t23
    # Array descriptor D_INT allocated (40 bytes)
    %arr_B_DOUBLE =l alloc8 64
    storel 0, %arr_B_DOUBLE
    %t24 =l add %arr_B_DOUBLE, 8
    storel 0, %t24
    %t25 =l add %arr_B_DOUBLE, 16
    storel -1, %t25
    %t26 =l add %arr_B_DOUBLE, 24
    storel 0, %t26
    %t27 =l add %arr_B_DOUBLE, 32
    storew 0, %t27
    # Array descriptor B_DOUBLE allocated (40 bytes)
    %arr_H_INT =l alloc8 64
    storel 0, %arr_H_INT
    %t28 =l add %arr_H_INT, 8
    storel 0, %t28
    %t29 =l add %arr_H_INT, 16
    storel -1, %t29
    %t30 =l add %arr_H_INT, 24
    storel 0, %t30
    %t31 =l add %arr_H_INT, 32
    storew 0, %t31
    # Array descriptor H_INT allocated (40 bytes)
    %arr_E_DOUBLE =l alloc8 64
    storel 0, %arr_E_DOUBLE
    %t32 =l add %arr_E_DOUBLE, 8
    storel 0, %t32
    %t33 =l add %arr_E_DOUBLE, 16
    storel -1, %t33
    %t34 =l add %arr_E_DOUBLE, 24
    storel 0, %t34
    %t35 =l add %arr_E_DOUBLE, 32
    storew 0, %t35
    # Array descriptor E_DOUBLE allocated (40 bytes)
    %arr_S_STRING =l alloc8 64
    storel 0, %arr_S_STRING
    %t36 =l add %arr_S_STRING, 8
    storel 0, %t36
    %t37 =l add %arr_S_STRING, 16
    storel -1, %t37
    %t38 =l add %arr_S_STRING, 24
    storel 0, %t38
    %t39 =l add %arr_S_STRING, 32
    storew 0, %t39
    # Array descriptor S_STRING allocated (40 bytes)
    %arr_A_INT =l alloc8 64
    storel 0, %arr_A_INT
    %t40 =l add %arr_A_INT, 8
    storel 0, %t40
    %t41 =l add %arr_A_INT, 16
    storel -1, %t41
    %t42 =l add %arr_A_INT, 24
    storel 0, %t42
    %t43 =l add %arr_A_INT, 32
    storew 0, %t43
    # Array descriptor A_INT allocated (40 bytes)

    # Program basic blocks (CFG-driven)
    jmp @block_0

@block_0
    # Block 0 (Entry) [Lines: 10, 20, 30, 40, 50, 60, 70]
    # Line 20
    %t44 =l copy $data_str.0
    %t45 =l call $string_new_utf8(l %t44)
    call $basic_print_string_desc(l %t45)
    call $basic_print_newline()
    # Line 30
    %t46 =l copy $data_str.1
    %t47 =l call $string_new_utf8(l %t46)
    call $basic_print_string_desc(l %t47)
    call $basic_print_newline()
    # Line 50
    %t48 =l copy $data_str.2
    %t49 =l call $string_new_utf8(l %t48)
    call $basic_print_string_desc(l %t49)
    call $basic_print_newline()
    # Line 60
    # DIM A_INT with descriptor (dope vector)
    %t50 =d copy d_10.000000
    %t51 =l dtosi %t50
    %t52 =w add %t51, 1
    %t53 =l extsw %t52
    %t54 =l mul %t53, 4
    %t55 =l call $malloc(l %t54)
    call $memset(l %t55, w 0, l %t54)
    storel %t55, %arr_A_INT
    %t56 =l add %arr_A_INT, 8
    storel 0, %t56
    %t57 =l add %arr_A_INT, 16
    %t58 =l extsw %t51
    storel %t58, %t57
    %t59 =l add %arr_A_INT, 24
    storel 0, %t59
    %t60 =l add %arr_A_INT, 32
    storel 0, %t60
    %t61 =l add %arr_A_INT, 40
    storel 4, %t61
    %t62 =l add %arr_A_INT, 48
    storew 1, %t62
    %t63 =l add %arr_A_INT, 52
    storew 0, %t63
    %t64 =l add %arr_A_INT, 56
    storeb 37, %t64
    # 1D Array A_INT descriptor initialized (element size: 4 bytes)
    jmp @block_1

@block_1
    # Block 1 (FOR Init)
    # Line 70
    %t65 =d copy d_1.000000
    %t66 =l dtosi %t65
    %var_I =l copy %t66
    %var_I_ =l copy %var_I
    %t67 =l copy 1
    %step_I_ =l copy %t67
    %t68 =d copy d_10.000000
    %t69 =l dtosi %t68
    %end_I_ =l copy %t69

@block_2
    # Block 2 (FOR Loop Check)
    %t70 =w csltl %step_I_, 0
    %t71 =w cslel %var_I, %end_I_
    %t72 =w csgel %var_I, %end_I_
    %t73 =w ceqw %t70, 0
    %t74 =w and %t70, %t72
    %t75 =w and %t73, %t71
    %t76 =w or %t74, %t75
    jnz %t76, @block_3, @block_4

@block_3
    # Block 3 (FOR Loop Body) [Lines: 80, 90]
    # Line 80
    %t77 =d copy d_10.000000
    %t78 =d sltof %var_I
    %t79 =d mul %t78, %t77
    # Array assignment: A_INT(...) = value
    # Get array element pointer for A_INT
    %t80 =l add %arr_A_INT, 8
    %t81 =l loadl %t80
    %t82 =l add %arr_A_INT, 16
    %t83 =l loadl %t82
    %t84 =l extsw %var_I
    %t85 =w csgel %t84, %t81
    %t86 =w cslel %t84, %t83
    %t87 =w and %t85, %t86
    jnz %t87, @L0, @L1
@L1
    call $basic_array_bounds_error(l %t84, l %t81, l %t83)
@L0
    %t88 =l sub %t84, %t81
    %t89 =l add %arr_A_INT, 40
    %t90 =l loadl %t89
    %t91 =l mul %t88, %t90
    %t92 =l loadl %arr_A_INT
    %t93 =l add %t92, %t91
    %t94 =w dtosi %t79
    storew %t94, %t93
    # Line 90
    %t95 =l add %var_I, %step_I_
    %var_I =l copy %t95
    %var_I_ =l copy %var_I
    # NEXT: increment and jump back to FOR header
    jmp @block_2

@block_4
    # Block 4 (After FOR) [Lines: 100, 110, 120, 130, 140, 150, 160, 170, 180, 190]
    # Line 100
    %t96 =l copy $data_str.3
    %t97 =l call $string_new_utf8(l %t96)
    call $basic_print_string_desc(l %t97)
    %t98 =d copy d_5.000000
    %t99 =l dtosi %t98
    # Array access A_INT with bounds check
    %t100 =l add %arr_A_INT, 8
    %t101 =l loadl %t100
    %t102 =l add %arr_A_INT, 16
    %t103 =l loadl %t102
    %t104 =l extsw %t99
    %t105 =w csgel %t104, %t101
    %t106 =w cslel %t104, %t103
    %t107 =w and %t105, %t106
    jnz %t107, @L2, @L3
@L3
    call $basic_array_bounds_error(l %t104, l %t101, l %t103)
@L2
    %t108 =l sub %t104, %t101
    %t109 =l add %arr_A_INT, 40
    %t110 =l loadl %t109
    %t111 =l mul %t108, %t110
    %t112 =l loadl %arr_A_INT
    %t113 =l add %t112, %t111
    %t114 =w loadw %t113
    %t115 =l extsw %t114
    call $basic_print_int(l %t115)
    call $basic_print_newline()
    # Line 110
    %t116 =d copy d_5.000000
    %t117 =l dtosi %t116
    # Array access A_INT with bounds check
    %t118 =l add %arr_A_INT, 8
    %t119 =l loadl %t118
    %t120 =l add %arr_A_INT, 16
    %t121 =l loadl %t120
    %t122 =l extsw %t117
    %t123 =w csgel %t122, %t119
    %t124 =w cslel %t122, %t121
    %t125 =w and %t123, %t124
    jnz %t125, @L4, @L5
@L5
    call $basic_array_bounds_error(l %t122, l %t119, l %t121)
@L4
    %t126 =l sub %t122, %t119
    %t127 =l add %arr_A_INT, 40
    %t128 =l loadl %t127
    %t129 =l mul %t126, %t128
    %t130 =l loadl %arr_A_INT
    %t131 =l add %t130, %t129
    %t132 =w loadw %t131
    %t133 =d copy d_50.000000
    %t135 =l extsw %t132
    %t134 =d sltof %t135
    %t137 =w cned %t134, %t133
    %t138 =w cnew %t137, 0
    jnz %t138, @then_6, @else_7
@then_6
    %t139 =l copy $data_str.4
    %t140 =l call $string_new_utf8(l %t139)
    call $basic_print_string_desc(l %t140)
    call $basic_print_newline()
    jmp @exit
@else_7
    jmp @endif_8
@endif_8
    # Line 120
    # ERASE arrays (free data and reset descriptor)
    # ERASE array A_INT
    call $array_descriptor_erase(l %arr_A_INT)
    # Array A_INT erased
    # Line 130
    %t141 =l copy $data_str.5
    %t142 =l call $string_new_utf8(l %t141)
    call $basic_print_string_desc(l %t142)
    call $basic_print_newline()
    # Line 140
    %t143 =l copy $data_str.6
    %t144 =l call $string_new_utf8(l %t143)
    call $basic_print_string_desc(l %t144)
    call $basic_print_newline()
    # Line 150
    %t145 =l copy $data_str.1
    %t146 =l call $string_new_utf8(l %t145)
    call $basic_print_string_desc(l %t146)
    call $basic_print_newline()
    # Line 170
    %t147 =l copy $data_str.7
    %t148 =l call $string_new_utf8(l %t147)
    call $basic_print_string_desc(l %t148)
    call $basic_print_newline()
    # Line 180
    # DIM B_DOUBLE with descriptor (dope vector)
    %t149 =d copy d_5.000000
    %t150 =l dtosi %t149
    %t151 =w add %t150, 1
    %t152 =l extsw %t151
    %t153 =l mul %t152, 8
    %t154 =l call $malloc(l %t153)
    call $memset(l %t154, w 0, l %t153)
    storel %t154, %arr_B_DOUBLE
    %t155 =l add %arr_B_DOUBLE, 8
    storel 0, %t155
    %t156 =l add %arr_B_DOUBLE, 16
    %t157 =l extsw %t150
    storel %t157, %t156
    %t158 =l add %arr_B_DOUBLE, 24
    storel 0, %t158
    %t159 =l add %arr_B_DOUBLE, 32
    storel 0, %t159
    %t160 =l add %arr_B_DOUBLE, 40
    storel 8, %t160
    %t161 =l add %arr_B_DOUBLE, 48
    storew 1, %t161
    %t162 =l add %arr_B_DOUBLE, 52
    storew 0, %t162
    %t163 =l add %arr_B_DOUBLE, 56
    storeb 35, %t163
    # 1D Array B_DOUBLE descriptor initialized (element size: 8 bytes)
    jmp @block_5

@block_5
    # Block 5 (FOR Init)
    # Line 190
    %t164 =d copy d_1.000000
    %t165 =l dtosi %t164
    %var_I =l copy %t165
    %var_I_ =l copy %var_I
    %t166 =l copy 1
    %step_I_ =l copy %t166
    %t167 =d copy d_5.000000
    %t168 =l dtosi %t167
    %end_I_ =l copy %t168

@block_6
    # Block 6 (FOR Loop Check)
    %t169 =w csltl %step_I_, 0
    %t170 =w cslel %var_I, %end_I_
    %t171 =w csgel %var_I, %end_I_
    %t172 =w ceqw %t169, 0
    %t173 =w and %t169, %t171
    %t174 =w and %t172, %t170
    %t175 =w or %t173, %t174
    jnz %t175, @block_7, @block_8

@block_7
    # Block 7 (FOR Loop Body) [Lines: 200, 210]
    # Line 200
    %t176 =d copy d_2.500000
    %t177 =d sltof %var_I
    %t178 =d mul %t177, %t176
    # Array assignment: B_DOUBLE(...) = value
    # Get array element pointer for B_DOUBLE
    %t179 =l add %arr_B_DOUBLE, 8
    %t180 =l loadl %t179
    %t181 =l add %arr_B_DOUBLE, 16
    %t182 =l loadl %t181
    %t183 =l extsw %var_I
    %t184 =w csgel %t183, %t180
    %t185 =w cslel %t183, %t182
    %t186 =w and %t184, %t185
    jnz %t186, @L9, @L10
@L10
    call $basic_array_bounds_error(l %t183, l %t180, l %t182)
@L9
    %t187 =l sub %t183, %t180
    %t188 =l add %arr_B_DOUBLE, 40
    %t189 =l loadl %t188
    %t190 =l mul %t187, %t189
    %t191 =l loadl %arr_B_DOUBLE
    %t192 =l add %t191, %t190
    stored %t178, %t192
    # Line 210
    %t193 =l add %var_I, %step_I_
    %var_I =l copy %t193
    %var_I_ =l copy %var_I
    # NEXT: increment and jump back to FOR header
    jmp @block_6

@block_8
    # Block 8 (After FOR) [Lines: 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440]
    # Line 220
    %t194 =l copy $data_str.8
    %t195 =l call $string_new_utf8(l %t194)
    call $basic_print_string_desc(l %t195)
    %t196 =d copy d_3.000000
    %t197 =l dtosi %t196
    # Array access B_DOUBLE with bounds check
    %t198 =l add %arr_B_DOUBLE, 8
    %t199 =l loadl %t198
    %t200 =l add %arr_B_DOUBLE, 16
    %t201 =l loadl %t200
    %t202 =l extsw %t197
    %t203 =w csgel %t202, %t199
    %t204 =w cslel %t202, %t201
    %t205 =w and %t203, %t204
    jnz %t205, @L11, @L12
@L12
    call $basic_array_bounds_error(l %t202, l %t199, l %t201)
@L11
    %t206 =l sub %t202, %t199
    %t207 =l add %arr_B_DOUBLE, 40
    %t208 =l loadl %t207
    %t209 =l mul %t206, %t208
    %t210 =l loadl %arr_B_DOUBLE
    %t211 =l add %t210, %t209
    %t212 =d loadd %t211
    call $basic_print_double(d %t212)
    call $basic_print_newline()
    # Line 230
    %t213 =d copy d_3.000000
    %t214 =l dtosi %t213
    # Array access B_DOUBLE with bounds check
    %t215 =l add %arr_B_DOUBLE, 8
    %t216 =l loadl %t215
    %t217 =l add %arr_B_DOUBLE, 16
    %t218 =l loadl %t217
    %t219 =l extsw %t214
    %t220 =w csgel %t219, %t216
    %t221 =w cslel %t219, %t218
    %t222 =w and %t220, %t221
    jnz %t222, @L13, @L14
@L14
    call $basic_array_bounds_error(l %t219, l %t216, l %t218)
@L13
    %t223 =l sub %t219, %t216
    %t224 =l add %arr_B_DOUBLE, 40
    %t225 =l loadl %t224
    %t226 =l mul %t223, %t225
    %t227 =l loadl %arr_B_DOUBLE
    %t228 =l add %t227, %t226
    %t229 =d loadd %t228
    %t230 =d copy d_7.500000
    %t232 =w cned %t229, %t230
    %t233 =w cnew %t232, 0
    jnz %t233, @then_15, @else_16
@then_15
    %t234 =l copy $data_str.4
    %t235 =l call $string_new_utf8(l %t234)
    call $basic_print_string_desc(l %t235)
    call $basic_print_newline()
    jmp @exit
@else_16
    jmp @endif_17
@endif_17
    # Line 240
    # ERASE arrays (free data and reset descriptor)
    # ERASE array B_DOUBLE
    call $array_descriptor_erase(l %arr_B_DOUBLE)
    # Array B_DOUBLE erased
    # Line 250
    %t236 =l copy $data_str.9
    %t237 =l call $string_new_utf8(l %t236)
    call $basic_print_string_desc(l %t237)
    call $basic_print_newline()
    # Line 260
    %t238 =l copy $data_str.10
    %t239 =l call $string_new_utf8(l %t238)
    call $basic_print_string_desc(l %t239)
    call $basic_print_newline()
    # Line 270
    %t240 =l copy $data_str.1
    %t241 =l call $string_new_utf8(l %t240)
    call $basic_print_string_desc(l %t241)
    call $basic_print_newline()
    # Line 290
    %t242 =l copy $data_str.11
    %t243 =l call $string_new_utf8(l %t242)
    call $basic_print_string_desc(l %t243)
    call $basic_print_newline()
    # Line 300
    # DIM C_STRING with descriptor (dope vector)
    %t244 =d copy d_3.000000
    %t245 =l dtosi %t244
    %t246 =w add %t245, 1
    %t247 =l extsw %t246
    %t248 =l mul %t247, 8
    %t249 =l call $malloc(l %t248)
    call $memset(l %t249, w 0, l %t248)
    storel %t249, %arr_C_STRING
    %t250 =l add %arr_C_STRING, 8
    storel 0, %t250
    %t251 =l add %arr_C_STRING, 16
    %t252 =l extsw %t245
    storel %t252, %t251
    %t253 =l add %arr_C_STRING, 24
    storel 0, %t253
    %t254 =l add %arr_C_STRING, 32
    storel 0, %t254
    %t255 =l add %arr_C_STRING, 40
    storel 8, %t255
    %t256 =l add %arr_C_STRING, 48
    storew 1, %t256
    %t257 =l add %arr_C_STRING, 52
    storew 0, %t257
    %t258 =l add %arr_C_STRING, 56
    storeb 36, %t258
    # 1D Array C_STRING descriptor initialized (element size: 8 bytes)
    # Line 310
    %t259 =l copy $data_str.12
    %t260 =l call $string_new_utf8(l %t259)
    # Array assignment: C_STRING(...) = value
    %t261 =d copy d_1.000000
    %t262 =l dtosi %t261
    # Get array element pointer for C_STRING
    %t263 =l add %arr_C_STRING, 8
    %t264 =l loadl %t263
    %t265 =l add %arr_C_STRING, 16
    %t266 =l loadl %t265
    %t267 =l extsw %t262
    %t268 =w csgel %t267, %t264
    %t269 =w cslel %t267, %t266
    %t270 =w and %t268, %t269
    jnz %t270, @L18, @L19
@L19
    call $basic_array_bounds_error(l %t267, l %t264, l %t266)
@L18
    %t271 =l sub %t267, %t264
    %t272 =l add %arr_C_STRING, 40
    %t273 =l loadl %t272
    %t274 =l mul %t271, %t273
    %t275 =l loadl %arr_C_STRING
    %t276 =l add %t275, %t274
    storel %t260, %t276
    # Line 320
    %t277 =l copy $data_str.13
    %t278 =l call $string_new_utf8(l %t277)
    # Array assignment: C_STRING(...) = value
    %t279 =d copy d_2.000000
    %t280 =l dtosi %t279
    # Get array element pointer for C_STRING
    %t281 =l add %arr_C_STRING, 8
    %t282 =l loadl %t281
    %t283 =l add %arr_C_STRING, 16
    %t284 =l loadl %t283
    %t285 =l extsw %t280
    %t286 =w csgel %t285, %t282
    %t287 =w cslel %t285, %t284
    %t288 =w and %t286, %t287
    jnz %t288, @L20, @L21
@L21
    call $basic_array_bounds_error(l %t285, l %t282, l %t284)
@L20
    %t289 =l sub %t285, %t282
    %t290 =l add %arr_C_STRING, 40
    %t291 =l loadl %t290
    %t292 =l mul %t289, %t291
    %t293 =l loadl %arr_C_STRING
    %t294 =l add %t293, %t292
    storel %t278, %t294
    # Line 330
    %t295 =l copy $data_str.14
    %t296 =l call $string_new_utf8(l %t295)
    # Array assignment: C_STRING(...) = value
    %t297 =d copy d_3.000000
    %t298 =l dtosi %t297
    # Get array element pointer for C_STRING
    %t299 =l add %arr_C_STRING, 8
    %t300 =l loadl %t299
    %t301 =l add %arr_C_STRING, 16
    %t302 =l loadl %t301
    %t303 =l extsw %t298
    %t304 =w csgel %t303, %t300
    %t305 =w cslel %t303, %t302
    %t306 =w and %t304, %t305
    jnz %t306, @L22, @L23
@L23
    call $basic_array_bounds_error(l %t303, l %t300, l %t302)
@L22
    %t307 =l sub %t303, %t300
    %t308 =l add %arr_C_STRING, 40
    %t309 =l loadl %t308
    %t310 =l mul %t307, %t309
    %t311 =l loadl %arr_C_STRING
    %t312 =l add %t311, %t310
    storel %t296, %t312
    # Line 340
    %t313 =l copy $data_str.15
    %t314 =l call $string_new_utf8(l %t313)
    call $basic_print_string_desc(l %t314)
    %t315 =d copy d_2.000000
    %t316 =l dtosi %t315
    # Array access C_STRING with bounds check
    %t317 =l add %arr_C_STRING, 8
    %t318 =l loadl %t317
    %t319 =l add %arr_C_STRING, 16
    %t320 =l loadl %t319
    %t321 =l extsw %t316
    %t322 =w csgel %t321, %t318
    %t323 =w cslel %t321, %t320
    %t324 =w and %t322, %t323
    jnz %t324, @L24, @L25
@L25
    call $basic_array_bounds_error(l %t321, l %t318, l %t320)
@L24
    %t325 =l sub %t321, %t318
    %t326 =l add %arr_C_STRING, 40
    %t327 =l loadl %t326
    %t328 =l mul %t325, %t327
    %t329 =l loadl %arr_C_STRING
    %t330 =l add %t329, %t328
    %t331 =l loadl %t330
    call $basic_print_string_desc(l %t331)
    call $basic_print_newline()
    # Line 350
    # ERASE arrays (free data and reset descriptor)
    # ERASE array C_STRING
    call $array_descriptor_erase(l %arr_C_STRING)
    # Array C_STRING erased
    # Line 360
    %t332 =l copy $data_str.16
    %t333 =l call $string_new_utf8(l %t332)
    call $basic_print_string_desc(l %t333)
    call $basic_print_newline()
    # Line 370
    %t334 =l copy $data_str.17
    %t335 =l call $string_new_utf8(l %t334)
    call $basic_print_string_desc(l %t335)
    call $basic_print_newline()
    # Line 380
    %t336 =l copy $data_str.1
    %t337 =l call $string_new_utf8(l %t336)
    call $basic_print_string_desc(l %t337)
    call $basic_print_newline()
    # Line 400
    %t338 =l copy $data_str.18
    %t339 =l call $string_new_utf8(l %t338)
    call $basic_print_string_desc(l %t339)
    call $basic_print_newline()
    # Line 410
    # DIM D_INT with descriptor (dope vector)
    %t340 =d copy d_5.000000
    %t341 =l dtosi %t340
    %t342 =w add %t341, 1
    %t343 =l extsw %t342
    %t344 =l mul %t343, 4
    %t345 =l call $malloc(l %t344)
    call $memset(l %t345, w 0, l %t344)
    storel %t345, %arr_D_INT
    %t346 =l add %arr_D_INT, 8
    storel 0, %t346
    %t347 =l add %arr_D_INT, 16
    %t348 =l extsw %t341
    storel %t348, %t347
    %t349 =l add %arr_D_INT, 24
    storel 0, %t349
    %t350 =l add %arr_D_INT, 32
    storel 0, %t350
    %t351 =l add %arr_D_INT, 40
    storel 4, %t351
    %t352 =l add %arr_D_INT, 48
    storew 1, %t352
    %t353 =l add %arr_D_INT, 52
    storew 0, %t353
    %t354 =l add %arr_D_INT, 56
    storeb 37, %t354
    # 1D Array D_INT descriptor initialized (element size: 4 bytes)
    # Line 420
    # DIM E_DOUBLE with descriptor (dope vector)
    %t355 =d copy d_5.000000
    %t356 =l dtosi %t355
    %t357 =w add %t356, 1
    %t358 =l extsw %t357
    %t359 =l mul %t358, 8
    %t360 =l call $malloc(l %t359)
    call $memset(l %t360, w 0, l %t359)
    storel %t360, %arr_E_DOUBLE
    %t361 =l add %arr_E_DOUBLE, 8
    storel 0, %t361
    %t362 =l add %arr_E_DOUBLE, 16
    %t363 =l extsw %t356
    storel %t363, %t362
    %t364 =l add %arr_E_DOUBLE, 24
    storel 0, %t364
    %t365 =l add %arr_E_DOUBLE, 32
    storel 0, %t365
    %t366 =l add %arr_E_DOUBLE, 40
    storel 8, %t366
    %t367 =l add %arr_E_DOUBLE, 48
    storew 1, %t367
    %t368 =l add %arr_E_DOUBLE, 52
    storew 0, %t368
    %t369 =l add %arr_E_DOUBLE, 56
    storeb 35, %t369
    # 1D Array E_DOUBLE descriptor initialized (element size: 8 bytes)
    # Line 430
    # DIM F_STRING with descriptor (dope vector)
    %t370 =d copy d_5.000000
    %t371 =l dtosi %t370
    %t372 =w add %t371, 1
    %t373 =l extsw %t372
    %t374 =l mul %t373, 8
    %t375 =l call $malloc(l %t374)
    call $memset(l %t375, w 0, l %t374)
    storel %t375, %arr_F_STRING
    %t376 =l add %arr_F_STRING, 8
    storel 0, %t376
    %t377 =l add %arr_F_STRING, 16
    %t378 =l extsw %t371
    storel %t378, %t377
    %t379 =l add %arr_F_STRING, 24
    storel 0, %t379
    %t380 =l add %arr_F_STRING, 32
    storel 0, %t380
    %t381 =l add %arr_F_STRING, 40
    storel 8, %t381
    %t382 =l add %arr_F_STRING, 48
    storew 1, %t382
    %t383 =l add %arr_F_STRING, 52
    storew 0, %t383
    %t384 =l add %arr_F_STRING, 56
    storeb 36, %t384
    # 1D Array F_STRING descriptor initialized (element size: 8 bytes)
    jmp @block_9

@block_9
    # Block 9 (FOR Init)
    # Line 440
    %t385 =d copy d_1.000000
    %t386 =l dtosi %t385
    %var_I =l copy %t386
    %var_I_ =l copy %var_I
    %t387 =l copy 1
    %step_I_ =l copy %t387
    %t388 =d copy d_5.000000
    %t389 =l dtosi %t388
    %end_I_ =l copy %t389

@block_10
    # Block 10 (FOR Loop Check)
    %t390 =w csltl %step_I_, 0
    %t391 =w cslel %var_I, %end_I_
    %t392 =w csgel %var_I, %end_I_
    %t393 =w ceqw %t390, 0
    %t394 =w and %t390, %t392
    %t395 =w and %t393, %t391
    %t396 =w or %t394, %t395
    jnz %t396, @block_11, @block_12

@block_11
    # Block 11 (FOR Loop Body) [Lines: 450, 460, 470, 480]
    # Line 450
    # Array assignment: D_INT(...) = value
    # Get array element pointer for D_INT
    %t397 =l add %arr_D_INT, 8
    %t398 =l loadl %t397
    %t399 =l add %arr_D_INT, 16
    %t400 =l loadl %t399
    %t401 =l extsw %var_I
    %t402 =w csgel %t401, %t398
    %t403 =w cslel %t401, %t400
    %t404 =w and %t402, %t403
    jnz %t404, @L26, @L27
@L27
    call $basic_array_bounds_error(l %t401, l %t398, l %t400)
@L26
    %t405 =l sub %t401, %t398
    %t406 =l add %arr_D_INT, 40
    %t407 =l loadl %t406
    %t408 =l mul %t405, %t407
    %t409 =l loadl %arr_D_INT
    %t410 =l add %t409, %t408
    %t411 =w copy %var_I
    storew %t411, %t410
    # Line 460
    %t412 =d copy d_1.100000
    %t413 =d sltof %var_I
    %t414 =d mul %t413, %t412
    # Array assignment: E_DOUBLE(...) = value
    # Get array element pointer for E_DOUBLE
    %t415 =l add %arr_E_DOUBLE, 8
    %t416 =l loadl %t415
    %t417 =l add %arr_E_DOUBLE, 16
    %t418 =l loadl %t417
    %t419 =l extsw %var_I
    %t420 =w csgel %t419, %t416
    %t421 =w cslel %t419, %t418
    %t422 =w and %t420, %t421
    jnz %t422, @L28, @L29
@L29
    call $basic_array_bounds_error(l %t419, l %t416, l %t418)
@L28
    %t423 =l sub %t419, %t416
    %t424 =l add %arr_E_DOUBLE, 40
    %t425 =l loadl %t424
    %t426 =l mul %t423, %t425
    %t427 =l loadl %arr_E_DOUBLE
    %t428 =l add %t427, %t426
    stored %t414, %t428
    # Line 470
    %t429 =l copy $data_str.19
    %t430 =l call $string_new_utf8(l %t429)
    # Array assignment: F_STRING(...) = value
    # Get array element pointer for F_STRING
    %t431 =l add %arr_F_STRING, 8
    %t432 =l loadl %t431
    %t433 =l add %arr_F_STRING, 16
    %t434 =l loadl %t433
    %t435 =l extsw %var_I
    %t436 =w csgel %t435, %t432
    %t437 =w cslel %t435, %t434
    %t438 =w and %t436, %t437
    jnz %t438, @L30, @L31
@L31
    call $basic_array_bounds_error(l %t435, l %t432, l %t434)
@L30
    %t439 =l sub %t435, %t432
    %t440 =l add %arr_F_STRING, 40
    %t441 =l loadl %t440
    %t442 =l mul %t439, %t441
    %t443 =l loadl %arr_F_STRING
    %t444 =l add %t443, %t442
    storel %t430, %t444
    # Line 480
    %t445 =l add %var_I, %step_I_
    %var_I =l copy %t445
    %var_I_ =l copy %var_I
    # NEXT: increment and jump back to FOR header
    jmp @block_10

@block_12
    # Block 12 (After FOR) [Lines: 490, 500, 510, 520, 530, 540, 550, 560, 570]
    # Line 490
    %t446 =l copy $data_str.20
    %t447 =l call $string_new_utf8(l %t446)
    call $basic_print_string_desc(l %t447)
    call $basic_print_newline()
    # Line 500
    # ERASE arrays (free data and reset descriptor)
    # ERASE array D_INT
    call $array_descriptor_erase(l %arr_D_INT)
    # Array D_INT erased
    # ERASE array E_DOUBLE
    call $array_descriptor_erase(l %arr_E_DOUBLE)
    # Array E_DOUBLE erased
    # ERASE array F_STRING
    call $array_descriptor_erase(l %arr_F_STRING)
    # Array F_STRING erased
    # Line 510
    %t448 =l copy $data_str.21
    %t449 =l call $string_new_utf8(l %t448)
    call $basic_print_string_desc(l %t449)
    call $basic_print_newline()
    # Line 520
    %t450 =l copy $data_str.22
    %t451 =l call $string_new_utf8(l %t450)
    call $basic_print_string_desc(l %t451)
    call $basic_print_newline()
    # Line 530
    %t452 =l copy $data_str.1
    %t453 =l call $string_new_utf8(l %t452)
    call $basic_print_string_desc(l %t453)
    call $basic_print_newline()
    # Line 550
    %t454 =l copy $data_str.23
    %t455 =l call $string_new_utf8(l %t454)
    call $basic_print_string_desc(l %t455)
    call $basic_print_newline()
    # Line 560
    # DIM H_INT with descriptor (dope vector)
    %t456 =d copy d_100.000000
    %t457 =l dtosi %t456
    %t458 =w add %t457, 1
    %t459 =l extsw %t458
    %t460 =l mul %t459, 4
    %t461 =l call $malloc(l %t460)
    call $memset(l %t461, w 0, l %t460)
    storel %t461, %arr_H_INT
    %t462 =l add %arr_H_INT, 8
    storel 0, %t462
    %t463 =l add %arr_H_INT, 16
    %t464 =l extsw %t457
    storel %t464, %t463
    %t465 =l add %arr_H_INT, 24
    storel 0, %t465
    %t466 =l add %arr_H_INT, 32
    storel 0, %t466
    %t467 =l add %arr_H_INT, 40
    storel 4, %t467
    %t468 =l add %arr_H_INT, 48
    storew 1, %t468
    %t469 =l add %arr_H_INT, 52
    storew 0, %t469
    %t470 =l add %arr_H_INT, 56
    storeb 37, %t470
    # 1D Array H_INT descriptor initialized (element size: 4 bytes)
    jmp @block_13

@block_13
    # Block 13 (FOR Init)
    # Line 570
    %t471 =d copy d_1.000000
    %t472 =l dtosi %t471
    %var_I =l copy %t472
    %var_I_ =l copy %var_I
    %t473 =l copy 1
    %step_I_ =l copy %t473
    %t474 =d copy d_100.000000
    %t475 =l dtosi %t474
    %end_I_ =l copy %t475

@block_14
    # Block 14 (FOR Loop Check)
    %t476 =w csltl %step_I_, 0
    %t477 =w cslel %var_I, %end_I_
    %t478 =w csgel %var_I, %end_I_
    %t479 =w ceqw %t476, 0
    %t480 =w and %t476, %t478
    %t481 =w and %t479, %t477
    %t482 =w or %t480, %t481
    jnz %t482, @block_15, @block_16

@block_15
    # Block 15 (FOR Loop Body) [Lines: 580, 590]
    # Line 580
    %t483 =d copy d_5.000000
    %t484 =d sltof %var_I
    %t485 =d mul %t484, %t483
    # Array assignment: H_INT(...) = value
    # Get array element pointer for H_INT
    %t486 =l add %arr_H_INT, 8
    %t487 =l loadl %t486
    %t488 =l add %arr_H_INT, 16
    %t489 =l loadl %t488
    %t490 =l extsw %var_I
    %t491 =w csgel %t490, %t487
    %t492 =w cslel %t490, %t489
    %t493 =w and %t491, %t492
    jnz %t493, @L32, @L33
@L33
    call $basic_array_bounds_error(l %t490, l %t487, l %t489)
@L32
    %t494 =l sub %t490, %t487
    %t495 =l add %arr_H_INT, 40
    %t496 =l loadl %t495
    %t497 =l mul %t494, %t496
    %t498 =l loadl %arr_H_INT
    %t499 =l add %t498, %t497
    %t500 =w dtosi %t485
    storew %t500, %t499
    # Line 590
    %t501 =l add %var_I, %step_I_
    %var_I =l copy %t501
    %var_I_ =l copy %var_I
    # NEXT: increment and jump back to FOR header
    jmp @block_14

@block_16
    # Block 16 (After FOR) [Lines: 600, 610, 620, 630, 640, 650, 660, 670, 680, 690, 700, 710, 720, 730, 740, 750, 760, 770, 780, 790, 800, 810, 820, 830, 840, 850, 860, 870, 880, 890, 900, 910, 920, 930, 940, 950, 960, 970]
    # Line 600
    %t502 =l copy $data_str.24
    %t503 =l call $string_new_utf8(l %t502)
    call $basic_print_string_desc(l %t503)
    %t504 =d copy d_50.000000
    %t505 =l dtosi %t504
    # Array access H_INT with bounds check
    %t506 =l add %arr_H_INT, 8
    %t507 =l loadl %t506
    %t508 =l add %arr_H_INT, 16
    %t509 =l loadl %t508
    %t510 =l extsw %t505
    %t511 =w csgel %t510, %t507
    %t512 =w cslel %t510, %t509
    %t513 =w and %t511, %t512
    jnz %t513, @L34, @L35
@L35
    call $basic_array_bounds_error(l %t510, l %t507, l %t509)
@L34
    %t514 =l sub %t510, %t507
    %t515 =l add %arr_H_INT, 40
    %t516 =l loadl %t515
    %t517 =l mul %t514, %t516
    %t518 =l loadl %arr_H_INT
    %t519 =l add %t518, %t517
    %t520 =w loadw %t519
    %t521 =l extsw %t520
    call $basic_print_int(l %t521)
    call $basic_print_newline()
    # Line 610
    %t522 =d copy d_50.000000
    %t523 =l dtosi %t522
    # Array access H_INT with bounds check
    %t524 =l add %arr_H_INT, 8
    %t525 =l loadl %t524
    %t526 =l add %arr_H_INT, 16
    %t527 =l loadl %t526
    %t528 =l extsw %t523
    %t529 =w csgel %t528, %t525
    %t530 =w cslel %t528, %t527
    %t531 =w and %t529, %t530
    jnz %t531, @L36, @L37
@L37
    call $basic_array_bounds_error(l %t528, l %t525, l %t527)
@L36
    %t532 =l sub %t528, %t525
    %t533 =l add %arr_H_INT, 40
    %t534 =l loadl %t533
    %t535 =l mul %t532, %t534
    %t536 =l loadl %arr_H_INT
    %t537 =l add %t536, %t535
    %t538 =w loadw %t537
    %t539 =d copy d_250.000000
    %t541 =l extsw %t538
    %t540 =d sltof %t541
    %t543 =w cned %t540, %t539
    %t544 =w cnew %t543, 0
    jnz %t544, @then_38, @else_39
@then_38
    %t545 =l copy $data_str.25
    %t546 =l call $string_new_utf8(l %t545)
    call $basic_print_string_desc(l %t546)
    call $basic_print_newline()
    jmp @exit
@else_39
    jmp @endif_40
@endif_40
    # Line 620
    # ERASE arrays (free data and reset descriptor)
    # ERASE array H_INT
    call $array_descriptor_erase(l %arr_H_INT)
    # Array H_INT erased
    # Line 630
    %t547 =l copy $data_str.26
    %t548 =l call $string_new_utf8(l %t547)
    call $basic_print_string_desc(l %t548)
    call $basic_print_newline()
    # Line 640
    %t549 =l copy $data_str.27
    %t550 =l call $string_new_utf8(l %t549)
    call $basic_print_string_desc(l %t550)
    call $basic_print_newline()
    # Line 650
    %t551 =l copy $data_str.1
    %t552 =l call $string_new_utf8(l %t551)
    call $basic_print_string_desc(l %t552)
    call $basic_print_newline()
    # Line 670
    %t553 =l copy $data_str.28
    %t554 =l call $string_new_utf8(l %t553)
    call $basic_print_string_desc(l %t554)
    call $basic_print_newline()
    # Line 680
    # DIM S_STRING with descriptor (dope vector)
    %t555 =d copy d_10.000000
    %t556 =l dtosi %t555
    %t557 =w add %t556, 1
    %t558 =l extsw %t557
    %t559 =l mul %t558, 8
    %t560 =l call $malloc(l %t559)
    call $memset(l %t560, w 0, l %t559)
    storel %t560, %arr_S_STRING
    %t561 =l add %arr_S_STRING, 8
    storel 0, %t561
    %t562 =l add %arr_S_STRING, 16
    %t563 =l extsw %t556
    storel %t563, %t562
    %t564 =l add %arr_S_STRING, 24
    storel 0, %t564
    %t565 =l add %arr_S_STRING, 32
    storel 0, %t565
    %t566 =l add %arr_S_STRING, 40
    storel 8, %t566
    %t567 =l add %arr_S_STRING, 48
    storew 1, %t567
    %t568 =l add %arr_S_STRING, 52
    storew 0, %t568
    %t569 =l add %arr_S_STRING, 56
    storeb 36, %t569
    # 1D Array S_STRING descriptor initialized (element size: 8 bytes)
    # Line 690
    %t570 =l copy $data_str.29
    %t571 =l call $string_new_utf8(l %t570)
    # Array assignment: S_STRING(...) = value
    %t572 =d copy d_1.000000
    %t573 =l dtosi %t572
    # Get array element pointer for S_STRING
    %t574 =l add %arr_S_STRING, 8
    %t575 =l loadl %t574
    %t576 =l add %arr_S_STRING, 16
    %t577 =l loadl %t576
    %t578 =l extsw %t573
    %t579 =w csgel %t578, %t575
    %t580 =w cslel %t578, %t577
    %t581 =w and %t579, %t580
    jnz %t581, @L41, @L42
@L42
    call $basic_array_bounds_error(l %t578, l %t575, l %t577)
@L41
    %t582 =l sub %t578, %t575
    %t583 =l add %arr_S_STRING, 40
    %t584 =l loadl %t583
    %t585 =l mul %t582, %t584
    %t586 =l loadl %arr_S_STRING
    %t587 =l add %t586, %t585
    storel %t571, %t587
    # Line 700
    %t588 =l copy $data_str.30
    %t589 =l call $string_new_utf8(l %t588)
    # Array assignment: S_STRING(...) = value
    %t590 =d copy d_2.000000
    %t591 =l dtosi %t590
    # Get array element pointer for S_STRING
    %t592 =l add %arr_S_STRING, 8
    %t593 =l loadl %t592
    %t594 =l add %arr_S_STRING, 16
    %t595 =l loadl %t594
    %t596 =l extsw %t591
    %t597 =w csgel %t596, %t593
    %t598 =w cslel %t596, %t595
    %t599 =w and %t597, %t598
    jnz %t599, @L43, @L44
@L44
    call $basic_array_bounds_error(l %t596, l %t593, l %t595)
@L43
    %t600 =l sub %t596, %t593
    %t601 =l add %arr_S_STRING, 40
    %t602 =l loadl %t601
    %t603 =l mul %t600, %t602
    %t604 =l loadl %arr_S_STRING
    %t605 =l add %t604, %t603
    storel %t589, %t605
    # Line 710
    %t606 =l copy $data_str.31
    %t607 =l call $string_new_utf8(l %t606)
    # Array assignment: S_STRING(...) = value
    %t608 =d copy d_3.000000
    %t609 =l dtosi %t608
    # Get array element pointer for S_STRING
    %t610 =l add %arr_S_STRING, 8
    %t611 =l loadl %t610
    %t612 =l add %arr_S_STRING, 16
    %t613 =l loadl %t612
    %t614 =l extsw %t609
    %t615 =w csgel %t614, %t611
    %t616 =w cslel %t614, %t613
    %t617 =w and %t615, %t616
    jnz %t617, @L45, @L46
@L46
    call $basic_array_bounds_error(l %t614, l %t611, l %t613)
@L45
    %t618 =l sub %t614, %t611
    %t619 =l add %arr_S_STRING, 40
    %t620 =l loadl %t619
    %t621 =l mul %t618, %t620
    %t622 =l loadl %arr_S_STRING
    %t623 =l add %t622, %t621
    storel %t607, %t623
    # Line 720
    %t624 =l copy $data_str.32
    %t625 =l call $string_new_utf8(l %t624)
    # Array assignment: S_STRING(...) = value
    %t626 =d copy d_4.000000
    %t627 =l dtosi %t626
    # Get array element pointer for S_STRING
    %t628 =l add %arr_S_STRING, 8
    %t629 =l loadl %t628
    %t630 =l add %arr_S_STRING, 16
    %t631 =l loadl %t630
    %t632 =l extsw %t627
    %t633 =w csgel %t632, %t629
    %t634 =w cslel %t632, %t631
    %t635 =w and %t633, %t634
    jnz %t635, @L47, @L48
@L48
    call $basic_array_bounds_error(l %t632, l %t629, l %t631)
@L47
    %t636 =l sub %t632, %t629
    %t637 =l add %arr_S_STRING, 40
    %t638 =l loadl %t637
    %t639 =l mul %t636, %t638
    %t640 =l loadl %arr_S_STRING
    %t641 =l add %t640, %t639
    storel %t625, %t641
    # Line 730
    %t642 =l copy $data_str.33
    %t643 =l call $string_new_utf8(l %t642)
    # Array assignment: S_STRING(...) = value
    %t644 =d copy d_5.000000
    %t645 =l dtosi %t644
    # Get array element pointer for S_STRING
    %t646 =l add %arr_S_STRING, 8
    %t647 =l loadl %t646
    %t648 =l add %arr_S_STRING, 16
    %t649 =l loadl %t648
    %t650 =l extsw %t645
    %t651 =w csgel %t650, %t647
    %t652 =w cslel %t650, %t649
    %t653 =w and %t651, %t652
    jnz %t653, @L49, @L50
@L50
    call $basic_array_bounds_error(l %t650, l %t647, l %t649)
@L49
    %t654 =l sub %t650, %t647
    %t655 =l add %arr_S_STRING, 40
    %t656 =l loadl %t655
    %t657 =l mul %t654, %t656
    %t658 =l loadl %arr_S_STRING
    %t659 =l add %t658, %t657
    storel %t643, %t659
    # Line 740
    %t660 =l copy $data_str.34
    %t661 =l call $string_new_utf8(l %t660)
    call $basic_print_string_desc(l %t661)
    %t662 =d copy d_3.000000
    %t663 =l dtosi %t662
    # Array access S_STRING with bounds check
    %t664 =l add %arr_S_STRING, 8
    %t665 =l loadl %t664
    %t666 =l add %arr_S_STRING, 16
    %t667 =l loadl %t666
    %t668 =l extsw %t663
    %t669 =w csgel %t668, %t665
    %t670 =w cslel %t668, %t667
    %t671 =w and %t669, %t670
    jnz %t671, @L51, @L52
@L52
    call $basic_array_bounds_error(l %t668, l %t665, l %t667)
@L51
    %t672 =l sub %t668, %t665
    %t673 =l add %arr_S_STRING, 40
    %t674 =l loadl %t673
    %t675 =l mul %t672, %t674
    %t676 =l loadl %arr_S_STRING
    %t677 =l add %t676, %t675
    %t678 =l loadl %t677
    call $basic_print_string_desc(l %t678)
    call $basic_print_newline()
    # Line 750
    # ERASE arrays (free data and reset descriptor)
    # ERASE array S_STRING
    call $array_descriptor_erase(l %arr_S_STRING)
    # Array S_STRING erased
    # Line 760
    %t679 =l copy $data_str.35
    %t680 =l call $string_new_utf8(l %t679)
    call $basic_print_string_desc(l %t680)
    call $basic_print_newline()
    # Line 770
    %t681 =l copy $data_str.36
    %t682 =l call $string_new_utf8(l %t681)
    call $basic_print_string_desc(l %t682)
    call $basic_print_newline()
    # Line 780
    %t683 =l copy $data_str.1
    %t684 =l call $string_new_utf8(l %t683)
    call $basic_print_string_desc(l %t684)
    call $basic_print_newline()
    # Line 800
    %t685 =l copy $data_str.37
    %t686 =l call $string_new_utf8(l %t685)
    call $basic_print_string_desc(l %t686)
    call $basic_print_newline()
    # Line 810
    # DIM X_INT with descriptor (dope vector)
    %t687 =d copy d_1.000000
    %t688 =l dtosi %t687
    %t689 =w add %t688, 1
    %t690 =l extsw %t689
    %t691 =l mul %t690, 4
    %t692 =l call $malloc(l %t691)
    call $memset(l %t692, w 0, l %t691)
    storel %t692, %arr_X_INT
    %t693 =l add %arr_X_INT, 8
    storel 0, %t693
    %t694 =l add %arr_X_INT, 16
    %t695 =l extsw %t688
    storel %t695, %t694
    %t696 =l add %arr_X_INT, 24
    storel 0, %t696
    %t697 =l add %arr_X_INT, 32
    storel 0, %t697
    %t698 =l add %arr_X_INT, 40
    storel 4, %t698
    %t699 =l add %arr_X_INT, 48
    storew 1, %t699
    %t700 =l add %arr_X_INT, 52
    storew 0, %t700
    %t701 =l add %arr_X_INT, 56
    storeb 37, %t701
    # 1D Array X_INT descriptor initialized (element size: 4 bytes)
    # Line 820
    # DIM Y_INT with descriptor (dope vector)
    %t702 =d copy d_50.000000
    %t703 =l dtosi %t702
    %t704 =w add %t703, 1
    %t705 =l extsw %t704
    %t706 =l mul %t705, 4
    %t707 =l call $malloc(l %t706)
    call $memset(l %t707, w 0, l %t706)
    storel %t707, %arr_Y_INT
    %t708 =l add %arr_Y_INT, 8
    storel 0, %t708
    %t709 =l add %arr_Y_INT, 16
    %t710 =l extsw %t703
    storel %t710, %t709
    %t711 =l add %arr_Y_INT, 24
    storel 0, %t711
    %t712 =l add %arr_Y_INT, 32
    storel 0, %t712
    %t713 =l add %arr_Y_INT, 40
    storel 4, %t713
    %t714 =l add %arr_Y_INT, 48
    storew 1, %t714
    %t715 =l add %arr_Y_INT, 52
    storew 0, %t715
    %t716 =l add %arr_Y_INT, 56
    storeb 37, %t716
    # 1D Array Y_INT descriptor initialized (element size: 4 bytes)
    # Line 830
    # DIM Z_INT with descriptor (dope vector)
    %t717 =d copy d_200.000000
    %t718 =l dtosi %t717
    %t719 =w add %t718, 1
    %t720 =l extsw %t719
    %t721 =l mul %t720, 4
    %t722 =l call $malloc(l %t721)
    call $memset(l %t722, w 0, l %t721)
    storel %t722, %arr_Z_INT
    %t723 =l add %arr_Z_INT, 8
    storel 0, %t723
    %t724 =l add %arr_Z_INT, 16
    %t725 =l extsw %t718
    storel %t725, %t724
    %t726 =l add %arr_Z_INT, 24
    storel 0, %t726
    %t727 =l add %arr_Z_INT, 32
    storel 0, %t727
    %t728 =l add %arr_Z_INT, 40
    storel 4, %t728
    %t729 =l add %arr_Z_INT, 48
    storew 1, %t729
    %t730 =l add %arr_Z_INT, 52
    storew 0, %t730
    %t731 =l add %arr_Z_INT, 56
    storeb 37, %t731
    # 1D Array Z_INT descriptor initialized (element size: 4 bytes)
    # Line 840
    %t732 =d copy d_99.000000
    # Array assignment: X_INT(...) = value
    %t733 =d copy d_1.000000
    %t734 =l dtosi %t733
    # Get array element pointer for X_INT
    %t735 =l add %arr_X_INT, 8
    %t736 =l loadl %t735
    %t737 =l add %arr_X_INT, 16
    %t738 =l loadl %t737
    %t739 =l extsw %t734
    %t740 =w csgel %t739, %t736
    %t741 =w cslel %t739, %t738
    %t742 =w and %t740, %t741
    jnz %t742, @L53, @L54
@L54
    call $basic_array_bounds_error(l %t739, l %t736, l %t738)
@L53
    %t743 =l sub %t739, %t736
    %t744 =l add %arr_X_INT, 40
    %t745 =l loadl %t744
    %t746 =l mul %t743, %t745
    %t747 =l loadl %arr_X_INT
    %t748 =l add %t747, %t746
    %t749 =w dtosi %t732
    storew %t749, %t748
    # Line 850
    %t750 =d copy d_250.000000
    # Array assignment: Y_INT(...) = value
    %t751 =d copy d_25.000000
    %t752 =l dtosi %t751
    # Get array element pointer for Y_INT
    %t753 =l add %arr_Y_INT, 8
    %t754 =l loadl %t753
    %t755 =l add %arr_Y_INT, 16
    %t756 =l loadl %t755
    %t757 =l extsw %t752
    %t758 =w csgel %t757, %t754
    %t759 =w cslel %t757, %t756
    %t760 =w and %t758, %t759
    jnz %t760, @L55, @L56
@L56
    call $basic_array_bounds_error(l %t757, l %t754, l %t756)
@L55
    %t761 =l sub %t757, %t754
    %t762 =l add %arr_Y_INT, 40
    %t763 =l loadl %t762
    %t764 =l mul %t761, %t763
    %t765 =l loadl %arr_Y_INT
    %t766 =l add %t765, %t764
    %t767 =w dtosi %t750
    storew %t767, %t766
    # Line 860
    %t768 =d copy d_1000.000000
    # Array assignment: Z_INT(...) = value
    %t769 =d copy d_100.000000
    %t770 =l dtosi %t769
    # Get array element pointer for Z_INT
    %t771 =l add %arr_Z_INT, 8
    %t772 =l loadl %t771
    %t773 =l add %arr_Z_INT, 16
    %t774 =l loadl %t773
    %t775 =l extsw %t770
    %t776 =w csgel %t775, %t772
    %t777 =w cslel %t775, %t774
    %t778 =w and %t776, %t777
    jnz %t778, @L57, @L58
@L58
    call $basic_array_bounds_error(l %t775, l %t772, l %t774)
@L57
    %t779 =l sub %t775, %t772
    %t780 =l add %arr_Z_INT, 40
    %t781 =l loadl %t780
    %t782 =l mul %t779, %t781
    %t783 =l loadl %arr_Z_INT
    %t784 =l add %t783, %t782
    %t785 =w dtosi %t768
    storew %t785, %t784
    # Line 870
    %t786 =l copy $data_str.38
    %t787 =l call $string_new_utf8(l %t786)
    call $basic_print_string_desc(l %t787)
    call $basic_print_newline()
    # Line 880
    # ERASE arrays (free data and reset descriptor)
    # ERASE array X_INT
    call $array_descriptor_erase(l %arr_X_INT)
    # Array X_INT erased
    # ERASE array Y_INT
    call $array_descriptor_erase(l %arr_Y_INT)
    # Array Y_INT erased
    # ERASE array Z_INT
    call $array_descriptor_erase(l %arr_Z_INT)
    # Array Z_INT erased
    # Line 890
    %t788 =l copy $data_str.39
    %t789 =l call $string_new_utf8(l %t788)
    call $basic_print_string_desc(l %t789)
    call $basic_print_newline()
    # Line 900
    %t790 =l copy $data_str.40
    %t791 =l call $string_new_utf8(l %t790)
    call $basic_print_string_desc(l %t791)
    call $basic_print_newline()
    # Line 910
    %t792 =l copy $data_str.1
    %t793 =l call $string_new_utf8(l %t792)
    call $basic_print_string_desc(l %t793)
    call $basic_print_newline()
    # Line 920
    %t794 =l copy $data_str.41
    %t795 =l call $string_new_utf8(l %t794)
    call $basic_print_string_desc(l %t795)
    call $basic_print_newline()
    # Line 930
    %t796 =l copy $data_str.1
    %t797 =l call $string_new_utf8(l %t796)
    call $basic_print_string_desc(l %t797)
    call $basic_print_newline()
    # Line 940
    %t798 =l copy $data_str.42
    %t799 =l call $string_new_utf8(l %t798)
    call $basic_print_string_desc(l %t799)
    call $basic_print_newline()
    # Line 950
    %t800 =l copy $data_str.43
    %t801 =l call $string_new_utf8(l %t800)
    call $basic_print_string_desc(l %t801)
    call $basic_print_newline()
    # Line 960
    %t802 =l copy $data_str.44
    %t803 =l call $string_new_utf8(l %t802)
    call $basic_print_string_desc(l %t803)
    call $basic_print_newline()
    # Line 970
    jmp @exit

@block_17
    # Block 17 (Exit)
    jmp @exit

@exit
    # Cleanup and return
    %t804 =l loadl %arr_Z_INT
    call $free(l %t804)
    %t805 =l loadl %arr_Y_INT
    call $free(l %t805)
    %t806 =l loadl %arr_F_STRING
    call $free(l %t806)
    %t807 =l loadl %arr_C_STRING
    call $free(l %t807)
    %t808 =l loadl %arr_X_INT
    call $free(l %t808)
    %t809 =l loadl %arr_D_INT
    call $free(l %t809)
    %t810 =l loadl %arr_B_DOUBLE
    call $free(l %t810)
    %t811 =l loadl %arr_H_INT
    call $free(l %t811)
    %t812 =l loadl %arr_E_DOUBLE
    call $free(l %t812)
    %t813 =l loadl %arr_S_STRING
    call $free(l %t813)
    %t814 =l loadl %arr_A_INT
    call $free(l %t814)
    call $basic_runtime_cleanup()
    ret 0
}
    # === DATA SECTION ===

    # No DATA statements - empty symbols
export data $__basic_data = { l 0 }
export data $__basic_data_types = { b 0 }
export data $__basic_data_ptr = { l 0 }

    # GOSUB return stack
export data $return_stack = { w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0, w 0 }
export data $return_sp = { w 0 }

    # String literals
data $data_str.0 = { b "=== ERASE Statement Tests ===", b 0 }
data $data_str.1 = { b "", b 0 }
data $data_str.2 = { b "Test 1: ERASE integer array", b 0 }
data $data_str.3 = { b "  Array populated: A%(5) = ", b 0 }
data $data_str.4 = { b "  ERROR: Array not populated", b 0 }
data $data_str.5 = { b "  ERASE A% executed", b 0 }
data $data_str.6 = { b "  PASS: Integer array erased", b 0 }
data $data_str.7 = { b "Test 2: ERASE double array", b 0 }
data $data_str.8 = { b "  Array populated: B#(3) = ", b 0 }
data $data_str.9 = { b "  ERASE B# executed", b 0 }
data $data_str.10 = { b "  PASS: Double array erased", b 0 }
data $data_str.11 = { b "Test 3: ERASE string array", b 0 }
data $data_str.12 = { b "Alpha", b 0 }
data $data_str.13 = { b "Beta", b 0 }
data $data_str.14 = { b "Gamma", b 0 }
data $data_str.15 = { b "  Array populated: C$(2) = ", b 0 }
data $data_str.16 = { b "  ERASE C$ executed", b 0 }
data $data_str.17 = { b "  PASS: String array erased", b 0 }
data $data_str.18 = { b "Test 4: ERASE multiple arrays", b 0 }
data $data_str.19 = { b "Item", b 0 }
data $data_str.20 = { b "  Three arrays populated", b 0 }
data $data_str.21 = { b "  ERASE D%, E#, F$ executed", b 0 }
data $data_str.22 = { b "  PASS: Multiple arrays erased", b 0 }
data $data_str.23 = { b "Test 5: ERASE large array", b 0 }
data $data_str.24 = { b "  Large array populated: H%(50) = ", b 0 }
data $data_str.25 = { b "  ERROR: Large array not populated", b 0 }
data $data_str.26 = { b "  ERASE H% executed (memory freed)", b 0 }
data $data_str.27 = { b "  PASS: Large array erased", b 0 }
data $data_str.28 = { b "Test 6: ERASE string array (string memory test)", b 0 }
data $data_str.29 = { b "String One", b 0 }
data $data_str.30 = { b "String Two", b 0 }
data $data_str.31 = { b "String Three", b 0 }
data $data_str.32 = { b "String Four", b 0 }
data $data_str.33 = { b "String Five", b 0 }
data $data_str.34 = { b "  String array populated: S$(3) = ", b 0 }
data $data_str.35 = { b "  ERASE S$ executed (strings freed)", b 0 }
data $data_str.36 = { b "  PASS: String array memory freed", b 0 }
data $data_str.37 = { b "Test 7: ERASE arrays of different sizes", b 0 }
data $data_str.38 = { b "  Small, medium, large arrays populated", b 0 }
data $data_str.39 = { b "  All arrays erased", b 0 }
data $data_str.40 = { b "  PASS: Different sized arrays erased", b 0 }
data $data_str.41 = { b "=== All ERASE Tests PASSED ===", b 0 }
data $data_str.42 = { b "Note: ERASE frees array memory but the array", b 0 }
data $data_str.43 = { b "      name remains declared. Use REDIM to", b 0 }
data $data_str.44 = { b "      reallocate with a different size.", b 0 }

