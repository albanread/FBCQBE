//
// qbe_codegen_main.cpp
// FasterBASIC QBE Code Generator - Main Orchestration
//
// This file contains the main code generation orchestration:
// - generate() entry point
// - emitHeader(), emitDataSection(), emitMainFunction()
// - emitBlock() - basic block emission
//

#include "../fasterbasic_qbe_codegen.h"
#include <iostream>
#include <iomanip>
#include <ctime>

namespace FasterBASIC {

// =============================================================================
// Constructor / Destructor
// =============================================================================

QBECodeGenerator::QBECodeGenerator()
    : m_programCFG(nullptr)
    , m_cfg(nullptr)
    , m_symbols(nullptr)
{
}

QBECodeGenerator::QBECodeGenerator(const QBECodeGenConfig& config)
    : m_config(config)
    , m_programCFG(nullptr)
    , m_cfg(nullptr)
    , m_symbols(nullptr)
{
}

QBECodeGenerator::~QBECodeGenerator() {
}

// =============================================================================
// Statistics
// =============================================================================

void QBECodeGenStats::print() const {
    std::cout << "=== QBE Code Generation Statistics ===\n";
    std::cout << "Instructions generated: " << instructionsGenerated << "\n";
    std::cout << "Labels generated: " << labelsGenerated << "\n";
    std::cout << "Variables used: " << variablesUsed << "\n";
    std::cout << "Arrays used: " << arraysUsed << "\n";
    std::cout << "Functions generated: " << functionsGenerated << "\n";
    std::cout << "Generation time: " << std::fixed << std::setprecision(2) 
              << generationTimeMs << " ms\n";
}

// =============================================================================
// Main Entry Point
// =============================================================================

std::string QBECodeGenerator::generate(const ProgramCFG& programCFG,
                                       const SymbolTable& symbols,
                                       const CompilerOptions& options) {
    clock_t startTime = clock();
    
    m_programCFG = &programCFG;
    m_symbols = &symbols;
    m_options = options;
    
    // Reset state
    m_output.str("");
    m_output.clear();
    m_variables.clear();
    m_varTypes.clear();
    m_arrays.clear();
    m_labels.clear();
    m_stringLiterals.clear();
    m_dataStrings.clear();
    m_loopStack.clear();
    m_gosubReturnLabels.clear();
    m_tempCounter = 0;
    m_labelCounter = 0;
    m_stringCounter = 0;
    m_inFunction = false;
    
    m_stats = QBECodeGenStats();
    
    // Generate QBE IL sections
    emitHeader();
    
    // Emit main function
    m_cfg = m_programCFG->mainCFG.get();
    emitMainFunction();
    
    // Emit user-defined functions
    for (const auto& funcName : m_programCFG->getFunctionNames()) {
        m_cfg = m_programCFG->getFunctionCFG(funcName);
        emitFunction(funcName);
    }
    
    emitDataSection();  // Emit after all functions so strings are collected
    
    clock_t endTime = clock();
    m_stats.generationTimeMs = (double)(endTime - startTime) / CLOCKS_PER_SEC * 1000.0;
    
    return m_output.str();
}

// =============================================================================
// Header Emission
// =============================================================================

void QBECodeGenerator::emitHeader() {
    emitComment("Generated by FasterBASIC QBE Code Generator");
    emitComment("Target: QBE IL (SSA format)");
    emitComment("");
    emitComment("External runtime functions from libbasic_runtime.a");
    emit("\n");
}

// =============================================================================
// Data Section Emission
// =============================================================================

void QBECodeGenerator::setDataValues(const DataPreprocessorResult& dataResult) {
    m_dataValues = dataResult.values;
    m_lineRestorePoints = dataResult.lineRestorePoints;
    m_labelRestorePoints = dataResult.labelRestorePoints;
}

void QBECodeGenerator::emitDataSection() {
    emitComment("=== DATA SECTION ===");
    emit("\n");
    
    // Emit DATA values if present
    if (!m_dataValues.empty()) {
        emitComment("DATA values");
        emit("export data $__basic_data = { ");
        
        for (size_t i = 0; i < m_dataValues.size(); ++i) {
            if (i > 0) emit(", ");
            
            const DataValue& val = m_dataValues[i];
            if (std::holds_alternative<int>(val)) {
                // Use 'l' (long/64-bit) for integers to match runtime int64_t
                emit("l " + std::to_string(std::get<int>(val)));
            } else if (std::holds_alternative<double>(val)) {
                // Use 'd' (double/64-bit) for doubles
                emit("d " + std::to_string(std::get<double>(val)));
            } else {
                // String pointer - add to string pool and reference it
                const std::string& str = std::get<std::string>(val);
                size_t strIdx = m_dataStrings.size();
                m_dataStrings.push_back(str);
                emit("l $data_str." + std::to_string(strIdx));
            }
        }
        emit(" }\n");
        
        // Emit type tags (0=INT, 1=DOUBLE, 2=STRING)
        emit("export data $__basic_data_types = { ");
        for (size_t i = 0; i < m_dataValues.size(); ++i) {
            if (i > 0) emit(", ");
            
            const DataValue& val = m_dataValues[i];
            if (std::holds_alternative<int>(val)) {
                emit("b 0");
            } else if (std::holds_alternative<double>(val)) {
                emit("b 1");
            } else {
                emit("b 2");
            }
        }
        emit(" }\n");
        
        // Emit data pointer (initialized to 0)
        emit("export data $__basic_data_ptr = { l 0 }\n");
        emit("\n");
    }
    
    // Emit string literals as data objects
    if (!m_dataStrings.empty()) {
        emitComment("String literals");
        for (size_t i = 0; i < m_dataStrings.size(); ++i) {
            emit("data $data_str." + std::to_string(i) + " = { ");
            emit("b \"" + escapeString(m_dataStrings[i]) + "\", b 0 }\n");
        }
    }
    
    emit("\n");
}

// =============================================================================
// Main Function Emission (CFG-driven)
// =============================================================================

void QBECodeGenerator::emitMainFunction() {
    emitComment("=== MAIN FUNCTION ===");
    emit("\n");
    
    // Function signature
    emit("export function w $main() {\n");
    m_stats.functionsGenerated++;
    
    // Entry block (always @start)
    emit("@start\n");
    m_stats.labelsGenerated++;
    
    emitComment("Initialize runtime");
    emit("    call $basic_runtime_init()\n");
    m_stats.instructionsGenerated++;
    emit("\n");
    
    // Declare all variables upfront (QBE requires this)
    emitComment("Variable declarations");
    
    // Collect all variables from symbol table
    // Note: Variable names in the symbol table are already mangled with type suffixes
    // e.g., "X_INT", "Y_DOUBLE", "S_STRING" (done by semantic analyzer)
    if (m_symbols) {
        for (const auto& [name, varSym] : m_symbols->variables) {
            std::string qbeType = getQBEType(varSym.type);
            // Create QBE SSA variable name: %var_<MANGLED_NAME>
            // Examples: %var_X_INT, %var_Y_DOUBLE, %var_S_STRING
            std::string varRef = "%var_" + name;
            m_variables[name] = m_variables.size();
            m_varTypes[name] = qbeType;
            
            // Initialize to zero
            if (varSym.type == VariableType::USER_DEFINED) {
                // User-defined type - allocate memory on stack
                size_t typeSize = calculateTypeSize(varSym.typeName);
                emit("    " + varRef + " =l alloc8 " + std::to_string(typeSize) + "\n");
                m_varTypes[name] = "l";  // UDTs are pointers
                m_varTypeNames[name] = varSym.typeName;  // Cache type name
            } else if (varSym.type == VariableType::STRING) {
                emit("    " + varRef + " =l call $str_alloc(w 0)\n");
            } else if (varSym.type == VariableType::INT) {
                emit("    " + varRef + " =w copy 0\n");
            } else if (varSym.type == VariableType::DOUBLE || varSym.type == VariableType::FLOAT) {
                // FLOAT and DOUBLE both map to QBE 'd' (64-bit double)
                emit("    " + varRef + " =d copy d_0.0\n");
            }
            m_stats.instructionsGenerated++;
            m_stats.variablesUsed++;
        }
        
        // Declare arrays (as descriptors - dope vectors)
        // Each array descriptor is 40 bytes (aligned):
        //   offset 0:  data pointer (8 bytes)
        //   offset 8:  lowerBound (8 bytes)
        //   offset 16: upperBound (8 bytes)
        //   offset 24: elementSize (8 bytes)
        //   offset 32: dimensions (4 bytes)
        //   offset 36: padding (4 bytes)
        for (const auto& [name, arraySym] : m_symbols->arrays) {
            std::string arrayRef = "%arr_" + name;
            m_arrays[name] = m_arrays.size();
            
            // Allocate descriptor on stack (40 bytes, 8-byte aligned)
            emit("    " + arrayRef + " =l alloc8 40\n");
            m_stats.instructionsGenerated++;
            
            // Initialize descriptor to null/zero state
            // Data pointer = NULL
            emit("    storel 0, " + arrayRef + "\n");
            
            // LowerBound = 0
            std::string lowerAddr = allocTemp("l");
            emit("    " + lowerAddr + " =l add " + arrayRef + ", 8\n");
            emit("    storel 0, " + lowerAddr + "\n");
            
            // UpperBound = -1 (indicates uninitialized/empty)
            std::string upperAddr = allocTemp("l");
            emit("    " + upperAddr + " =l add " + arrayRef + ", 16\n");
            emit("    storel -1, " + upperAddr + "\n");
            
            // ElementSize = 0 (will be set by DIM)
            std::string elemSizeAddr = allocTemp("l");
            emit("    " + elemSizeAddr + " =l add " + arrayRef + ", 24\n");
            emit("    storel 0, " + elemSizeAddr + "\n");
            
            // Dimensions = 0 (will be set by DIM)
            std::string dimsAddr = allocTemp("l");
            emit("    " + dimsAddr + " =l add " + arrayRef + ", 32\n");
            emit("    storew 0, " + dimsAddr + "\n");
            
            m_stats.instructionsGenerated += 10;
            m_stats.arraysUsed++;
            
            emitComment("Array descriptor " + name + " allocated (40 bytes)");
        }
    }
    emit("\n");
    
    // Emit all basic blocks from CFG
    emitComment("Program basic blocks (CFG-driven)");
    
    // Jump to entry block (skip @start)
    if (m_cfg && m_cfg->entryBlock >= 0 && m_cfg->entryBlock < m_cfg->getBlockCount()) {
        std::string entryLabel = getBlockLabel(m_cfg->entryBlock);
        emit("    jmp @" + entryLabel + "\n");
        m_stats.instructionsGenerated++;
    }
    emit("\n");
    
    // Emit each basic block
    if (m_cfg) {
        for (const auto& block : m_cfg->blocks) {
            emitBlock(block.get());
        }
    }
    
    // Exit block
    emit("@exit\n");
    m_stats.labelsGenerated++;
    emitComment("Cleanup and return");
    
    // Free all array data (from descriptors)
    if (m_symbols) {
        for (const auto& [name, arraySym] : m_symbols->arrays) {
            std::string arrayRef = "%arr_" + name;
            
            // Load data pointer from descriptor (offset 0)
            std::string dataPtr = allocTemp("l");
            emit("    " + dataPtr + " =l loadl " + arrayRef + "\n");
            
            // Free if not null
            emit("    call $free(l " + dataPtr + ")\n");
            
            m_stats.instructionsGenerated += 2;
        }
    }
    
    emit("    call $basic_runtime_cleanup()\n");
    emit("    ret 0\n");
    m_stats.instructionsGenerated += 2;
    
    emit("}\n");
}

// =============================================================================
// Function Context Management
// =============================================================================

void QBECodeGenerator::enterFunctionContext(const std::string& functionName) {
    m_inFunction = true;
    m_currentFunction = functionName;
    m_localVariables.clear();
    m_sharedVariables.clear();
    
    // Create function context for local array tracking
    // Determine if SUB or FUNCTION and return type
    bool isSub = true;  // Default to SUB
    VariableType returnType = VariableType::VOID;
    
    // Look up function in symbol table to get actual return type
    if (m_symbols && m_symbols->functions.find(functionName) != m_symbols->functions.end()) {
        const auto& funcSym = m_symbols->functions.at(functionName);
        returnType = funcSym.returnType;
        isSub = (returnType == VariableType::VOID);
    }
    
    FunctionContext ctx(functionName, returnType, isSub);
    ctx.tidyExitLabel = "tidy_exit_" + functionName;
    m_functionStack.push(ctx);
}

void QBECodeGenerator::exitFunctionContext() {
    // Pop function context (cleanup happens in emitFunctionEpilogue)
    if (!m_functionStack.empty()) {
        m_functionStack.pop();
    }
    
    m_inFunction = false;
    m_currentFunction = "";
    m_localVariables.clear();
    m_sharedVariables.clear();
}

// =============================================================================
// User-Defined Function Emission
// =============================================================================

void QBECodeGenerator::emitFunction(const std::string& functionName) {
    if (!m_cfg) return;
    
    enterFunctionContext(functionName);
    
    // Check if this is a DEF FN function (single-line expression function)
    bool isDefFn = (m_cfg->defStatement != nullptr);
    
    // Emit function header comment
    emitComment("=============================================================================");
    if (isDefFn) {
        emitComment("DEF FN: " + functionName);
    } else {
        emitComment("Function: " + functionName);
    }
    emitComment("=============================================================================");
    emit("\n");
    
    // Determine return type
    std::string qbeReturnType = "w";  // Default to word (int)
    if (m_cfg->returnType == VariableType::DOUBLE || m_cfg->returnType == VariableType::FLOAT) {
        qbeReturnType = "d";  // Double
    } else if (m_cfg->returnType == VariableType::STRING) {
        qbeReturnType = "l";  // Pointer (long)
    } else if (m_cfg->returnType == VariableType::UNKNOWN) {
        qbeReturnType = "w";  // SUBs return void (we use 0)
    }
    
    // Build parameter list
    std::string paramList;
    for (size_t i = 0; i < m_cfg->parameters.size(); ++i) {
        if (i > 0) paramList += ", ";
        
        std::string paramType = "w";  // Default to word
        if (i < m_cfg->parameterTypes.size()) {
            VariableType vt = m_cfg->parameterTypes[i];
            if (vt == VariableType::DOUBLE || vt == VariableType::FLOAT) {
                paramType = "d";
            } else if (vt == VariableType::STRING) {
                paramType = "l";  // String pointer
            }
        }
        
        paramList += paramType + " %" + m_cfg->parameters[i];
    }
    
    // Emit function signature
    emit("export function " + qbeReturnType + " $" + functionName + "(" + paramList + ") {\n");
    emit("@start\n");
    m_stats.labelsGenerated++;
    
    // Special handling for DEF FN - just evaluate expression and return
    if (isDefFn && m_cfg->defStatement && m_cfg->defStatement->body) {
        emitComment("DEF FN body - single expression");
        
        // Evaluate the expression
        std::string resultTemp = emitExpression(m_cfg->defStatement->body.get());
        
        // Return the result
        emit("    ret " + resultTemp + "\n");
        m_stats.instructionsGenerated++;
        emit("}\n");
        emit("\n");
        
        exitFunctionContext();
        return;
    }
    
    // Regular FUNCTION/SUB handling
    // Initialize function return variable (for FUNCTIONs)
    if (m_cfg->returnType != VariableType::UNKNOWN) {
        std::string returnVar = "%var_" + functionName;
        std::string initValue = "0";
        if (m_cfg->returnType == VariableType::DOUBLE || m_cfg->returnType == VariableType::FLOAT) {
            emit("    " + returnVar + " =d copy d_0.0\n");
        } else if (m_cfg->returnType == VariableType::STRING) {
            // Initialize to empty string via runtime
            emit("    " + returnVar + " =l call $basic_empty_string()\n");
        } else {
            emit("    " + returnVar + " =w copy " + initValue + "\n");
        }
        m_stats.instructionsGenerated++;
    }
    
    emitComment("Function body");
    
    // Jump to entry block
    if (m_cfg->entryBlock >= 0 && m_cfg->entryBlock < m_cfg->getBlockCount()) {
        std::string entryLabel = getBlockLabel(m_cfg->entryBlock);
        emit("    jmp @" + entryLabel + "\n");
        m_stats.instructionsGenerated++;
    }
    emit("\n");
    
    // Emit each basic block
    for (const auto& block : m_cfg->blocks) {
        emitBlock(block.get());
    }
    
    // Tidy exit block - cleanup local arrays, then fall through to exit
    if (!m_functionStack.empty()) {
        emit("@" + m_functionStack.top().tidyExitLabel + "\n");
        m_stats.labelsGenerated++;
        emitComment("Cleanup local arrays");
        
        // Free all local heap-allocated arrays
        for (const auto& arrayName : m_functionStack.top().localArrays) {
            std::string arrayRef = "%arr_" + arrayName;
            emit("    call $free(l " + arrayRef + ")\n");
            m_stats.instructionsGenerated++;
        }
        
        if (!m_functionStack.top().localArrays.empty()) {
            emitComment("Fall through to exit");
        }
    }
    
    // Exit block - return the function-name variable (or 0 for SUBs)
    emit("@exit\n");
    m_stats.labelsGenerated++;
    emitComment("Return from function");
    
    if (m_cfg->returnType != VariableType::UNKNOWN) {
        std::string returnVar = "%var_" + functionName;
        if (m_cfg->returnType == VariableType::DOUBLE || m_cfg->returnType == VariableType::FLOAT) {
            emit("    %retval =d copy " + returnVar + "\n");
            emit("    ret %retval\n");
        } else if (m_cfg->returnType == VariableType::STRING) {
            emit("    %retval =l copy " + returnVar + "\n");
            emit("    ret %retval\n");
        } else {
            emit("    %retval =w copy " + returnVar + "\n");
            emit("    ret %retval\n");
        }
    } else {
        // SUB returns 0
        emit("    ret 0\n");
    }
    m_stats.instructionsGenerated += 2;
    
    emit("}\n");
    emit("\n");
    
    exitFunctionContext();
}

// =============================================================================
// Basic Block Emission
// =============================================================================

void QBECodeGenerator::emitBlock(const BasicBlock* block) {
    if (!block) return;
    
    // Store current block for statement handlers
    m_currentBlock = block;
    m_lastStatementWasTerminator = false;
    
    // Emit block label
    std::string label = getBlockLabel(block->id);
    emit("@" + label + "\n");
    m_stats.labelsGenerated++;
    
    // Add debug comment with block info
    if (m_config.emitComments) {
        std::string comment = "Block " + std::to_string(block->id);
        if (!block->label.empty()) {
            comment += " (" + block->label + ")";
        }
        if (!block->lineNumbers.empty()) {
            comment += " [Lines: ";
            bool first = true;
            for (int line : block->lineNumbers) {
                if (!first) comment += ", ";
                comment += std::to_string(line);
                first = false;
            }
            comment += "]";
        }
        emitComment(comment);
    }
    
    // Check if this is a FOR loop check block (empty block that needs condition check)
    if (block->statements.empty() && !block->label.empty() && 
        block->label.find("FOR Loop Check") != std::string::npos) {
        
        // Find the FOR loop structure for this check block
        for (const auto& pair : m_cfg->forLoopStructure) {
            if (pair.second.checkBlock == block->id) {
                const auto& forBlocks = pair.second;
                std::string varName = forBlocks.variable;
                
                // Emit loop condition check: var <= end
                std::string varRef = getVariableRef(varName);
                std::string endVar = "%end_" + varName;
                std::string condTemp = allocTemp("w");
                emit("    " + condTemp + " =w cslew " + varRef + ", " + endVar + "\n");
                m_stats.instructionsGenerated++;
                
                // Store condition for CFG to emit conditional branch
                m_lastCondition = condTemp;
                break;
            }
        }
    }
    
    // Check if this is a SELECT CASE test block
    // Test blocks are empty but need to emit comparison logic
    else if (block->statements.empty() && !block->label.empty() && 
        block->label.find("CASE") != std::string::npos && 
        block->label.find("Test") != std::string::npos) {
        
        // This is a SELECT CASE test block
        // We need to emit comparison logic here
        // The comparison value and test value will be passed via the CFG context
        // For now, emit a placeholder that will be filled by the proper SELECT CASE implementation
        emitComment("SELECT CASE test block - comparison logic needed");
        
        // We need the SELECT CASE expression value and the CASE value(s)
        // This requires passing context from the SELECT block through the CFG
        // For now, we'll handle this in emitCase by storing the select value globally
        if (!m_selectCaseValue.empty() && m_currentCaseClauseIndex < m_caseClauseValues.size()) {
            // Emit comparison for this CASE clause
            const auto& values = m_caseClauseValues[m_currentCaseClauseIndex];
            
            if (values.size() == 1) {
                // Single value comparison
                std::string cmpTemp = allocTemp("w");
                emit("    " + cmpTemp + " =w ceqw " + m_selectCaseValue + ", " + values[0] + "\n");
                m_stats.instructionsGenerated++;
                m_lastCondition = cmpTemp;
            } else if (values.size() > 1) {
                // Multiple values - OR them together
                std::vector<std::string> comparisons;
                for (const auto& value : values) {
                    std::string cmpTemp = allocTemp("w");
                    emit("    " + cmpTemp + " =w ceqw " + m_selectCaseValue + ", " + value + "\n");
                    m_stats.instructionsGenerated++;
                    comparisons.push_back(cmpTemp);
                }
                
                // OR all comparisons
                std::string orTemp = comparisons[0];
                for (size_t i = 1; i < comparisons.size(); i++) {
                    std::string newOr = allocTemp("w");
                    emit("    " + newOr + " =w or " + orTemp + ", " + comparisons[i] + "\n");
                    m_stats.instructionsGenerated++;
                    orTemp = newOr;
                }
                m_lastCondition = orTemp;
            }
            
            m_currentCaseClauseIndex++;
        }
    }
    
    // Emit all statements in the block
    for (const Statement* stmt : block->statements) {
        if (stmt) {
            // Add line number comment if available
            if (m_config.emitComments) {
                int lineNum = block->getLineNumber(stmt);
                if (lineNum > 0) {
                    emitComment("Line " + std::to_string(lineNum));
                }
            }
            emitStatement(stmt);
        }
    }
    
    // Emit control flow based on successors
    // Only emit if last statement didn't already emit a terminator
    if (m_lastStatementWasTerminator) {
        // Statement already handled control flow (GOTO, RETURN, END)
        emit("\n");
        m_currentBlock = nullptr;
        return;
    }
    
    if (block->successors.empty()) {
        // No successors - jump to exit (tidy_exit for functions)
        emit("    jmp @" + getFunctionExitLabel() + "\n");
        m_stats.instructionsGenerated++;
    } else if (block->successors.size() == 1) {
        // Single successor - unconditional jump (if not fallthrough to next block)
        int nextBlockId = block->successors[0];
        
        // Check if this is a fallthrough to the next sequential block
        bool isFallthrough = (nextBlockId == block->id + 1);
        
        if (!isFallthrough) {
            std::string nextLabel = getBlockLabel(nextBlockId);
            emit("    jmp @" + nextLabel + "\n");
            m_stats.instructionsGenerated++;
        }
        // Otherwise, fall through naturally
    } else if (block->successors.size() == 2) {
        // Two successors - conditional branch
        // The last statement should have stored the condition in m_lastCondition
        if (!m_lastCondition.empty()) {
            std::string trueLabel = getBlockLabel(block->successors[0]);
            std::string falseLabel = getBlockLabel(block->successors[1]);
            emit("    jnz " + m_lastCondition + ", @" + trueLabel + ", @" + falseLabel + "\n");
            m_stats.instructionsGenerated++;
            m_lastCondition.clear();  // Reset for next block
        } else {
            // Fallback: jump to first successor
            std::string nextLabel = getBlockLabel(block->successors[0]);
            emit("    jmp @" + nextLabel + "\n");
            m_stats.instructionsGenerated++;
        }
    } else if (block->successors.size() > 2) {
        // Multiple successors (e.g., ON GOTO/GOSUB or SELECT CASE)
        // For now, just jump to first successor
        // TODO: Implement multi-way branches properly
        std::string nextLabel = getBlockLabel(block->successors[0]);
        emit("    jmp @" + nextLabel + "\n");
        m_stats.instructionsGenerated++;
    }
    
    emit("\n");
    
    // Clear current block
    m_currentBlock = nullptr;
}

} // namespace FasterBASIC