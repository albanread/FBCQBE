[DEBUG] compile_basic_to_il: Starting...
[DEBUG] Starting pass1_collectDeclarations
[DEBUG] Starting pass2_validate
[DEBUG] pass2_validate: processing 26 lines
[DEBUG] pass2_validate: line 1000 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1010 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1020 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1030 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1040 has 1 statements
[DEBUG] validateStatement called for type: 37
[DEBUG] pass2_validate: line 1050 has 1 statements
[DEBUG] validateStatement called for type: 37
[DEBUG] pass2_validate: line 1060 has 1 statements
[DEBUG] validateStatement called for type: 37
[DEBUG] pass2_validate: line 1070 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1080 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1090 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1100 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1110 has 1 statements
[DEBUG] validateStatement called for type: 25
[DEBUG] validateForStatement called for variable: m
[DEBUG] FOR stack PUSH at 0:0, stack size now: 1
[DEBUG] validateStatement called for type: 25
[DEBUG] validateForStatement called for variable: n
[DEBUG] FOR stack PUSH at 0:0, stack size now: 2
[DEBUG] validateStatement called for type: 7
[DEBUG] validateStatement called for type: 2
[DEBUG] FOR stack POP after body, stack size before pop: 2
[DEBUG] FOR stack size after pop: 1
[DEBUG] FOR stack POP after body, stack size before pop: 1
[DEBUG] FOR stack size after pop: 0
[DEBUG] pass2_validate: line 1120 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1130 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1140 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1150 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1160 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1170 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1180 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1190 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1200 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1210 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1220 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1230 has 1 statements
[DEBUG] validateStatement called for type: 2
[DEBUG] pass2_validate: line 1240 has 1 statements
[DEBUG] validateStatement called for type: 34
[DEBUG] pass2_validate: line 1250 has 1 statements
[DEBUG] validateStatement called for type: 93
[DEBUG] validateStatement called for type: 43
[DEBUG] validateStatement called for type: 22
[DEBUG] validateStatement called for type: 7
[DEBUG] validateStatement called for type: 22
[DEBUG] validateStatement called for type: 7
[DEBUG] validateStatement called for type: 7
[DEBUG] validateStatement called for type: 7
[DEBUG] validateStatement called for type: 7
[DEBUG] Finished pass2_validate
[DEBUG] validateControlFlow called, FOR stack size: 0
[INFO] Building complete ProgramCFG (main + all SUBs/FUNCTIONs)...
[INFO] ProgramCFG build successful!
[INFO] Main program CFG + 1 function/subroutine CFGs

╔══════════════════════════════════════════════════════════════════════════╗
║                    PROGRAM CFG ANALYSIS REPORT                           ║
╚══════════════════════════════════════════════════════════════════════════╝

Total CFGs: 2
  - Main Program: 1
  - Functions/Subs: 1


+==========================================================================+
|                       CFG ANALYSIS REPORT                                 |
+==========================================================================╝

Phase: Main Program
Function: main

------------------------------------------------------------------------------
SUMMARY METRICS
------------------------------------------------------------------------------
  Basic Statistics:
    Total Blocks:         12
    Total Edges:          13
    Entry Block:           0
    Exit Block:            1
    Total Statements:     28
    Reachable Blocks:     12
    Unreachable:           0
    Cyclomatic Complexity: 3 (LOW)

  Block Categories:
    Empty Blocks:          7
    Loop Headers:          2
    Loop Exits:            2
    Terminated:            1
    Multi-Pred:            2
    Multi-Succ:            2

  Edge Types:
    Conditional True:      4
    Jump:                  9

------------------------------------------------------------------------------
COMPACT FORMAT (for test validation)
------------------------------------------------------------------------------
CFG:main:B12:E13:S28:CC3:R12
EDGES: 0->2 2->3 3->4 3->6 4->7 7->8 8->9 8->11 9->10 10->8 11->5 5->3 6->1

==============================================================================
DETAILED BLOCK ANALYSIS
==============================================================================

+=== Block 0 (Entry) =======================================================+
| Flags: [ENTRY]
| Source Lines: 1000 1010 1020 1030 1040 1050 1060 1070 1080 1090
|               1100
| Statements: 11
|   Types: DimStatement×3, PrintStatement×8
|   Detail:
|     [ 0] PrintStatement (line 1000)
|     [ 1] PrintStatement (line 1010)
|     [ 2] PrintStatement (line 1020)
|     [ 3] PrintStatement (line 1030)
|     [ 4] DimStatement (line 1040)
|     [ 5] DimStatement (line 1050)
|     [ 6] DimStatement (line 1060)
|     [ 7] PrintStatement (line 1070)
|     [ 8] PrintStatement (line 1080)
|     [ 9] PrintStatement (line 1090)
|     [10] PrintStatement (line 1100)
| Predecessors (0): none
| Successors (1): 2
+============================================================================╝

+=== Block 1 (Exit) ========================================================+
| Flags: [EXIT] [EMPTY]
| Statements: 0
| Predecessors (1): 6
| Successors (0): none
+============================================================================╝

+=== Block 2 (For_Init) ====================================================+
| Flags: [NORMAL]
| Statements: 1
|   Types: ForStatement
|   Detail:
|     [ 0] ForStatement
| Predecessors (1): 0
| Successors (1): 3
+============================================================================╝

+=== Block 3 (For_Header) ==================================================+
| Flags: [LOOP_HEADER] [EMPTY]
| Statements: 0
| Predecessors (2): 2, 5
| Successors (2): 4, 6
+============================================================================╝

+=== Block 4 (For_Body) ====================================================+
| Flags: [EMPTY]
| Statements: 0
| Predecessors (1): 3
| Successors (1): 7
+============================================================================╝

+=== Block 5 (For_Increment) ===============================================+
| Flags: [EMPTY]
| Statements: 0
| Predecessors (1): 11
| Successors (1): 3
+============================================================================╝

+=== Block 6 (For_Exit) ====================================================+
| Flags: [TERMINATED] [LOOP_EXIT]
| Source Lines: 1120 1130 1140 1150 1160 1170 1180 1190 1200 1210
|               1220 1230
| Statements: 13
|   Types: EndStatement, PrintStatement×12
|   Detail:
|     [ 0] PrintStatement (line 1120)
|     [ 1] PrintStatement (line 1130)
|     [ 2] PrintStatement (line 1140)
|     [ 3] PrintStatement (line 1150)
|     [ 4] PrintStatement (line 1160)
|     [ 5] PrintStatement (line 1170)
|     [ 6] PrintStatement (line 1180)
|     [ 7] PrintStatement (line 1190)
|     [ 8] PrintStatement (line 1200)
|     [ 9] PrintStatement (line 1210)
|     [10] PrintStatement (line 1220)
|     [11] PrintStatement (line 1230)
|     [12] EndStatement
| Predecessors (1): 3
| Successors (1): 1
+============================================================================╝

+=== Block 7 (For_Init) ====================================================+
| Flags: [NORMAL]
| Statements: 1
|   Types: ForStatement
|   Detail:
|     [ 0] ForStatement
| Predecessors (1): 4
| Successors (1): 8
+============================================================================╝

+=== Block 8 (For_Header) ==================================================+
| Flags: [LOOP_HEADER] [EMPTY]
| Statements: 0
| Predecessors (2): 7, 10
| Successors (2): 9, 11
+============================================================================╝

+=== Block 9 (For_Body) ====================================================+
| Flags: [NORMAL]
| Statements: 2
|   Types: LetStatement, PrintStatement
|   Detail:
|     [ 0] LetStatement
|     [ 1] PrintStatement
| Predecessors (1): 8
| Successors (1): 10
+============================================================================╝

+=== Block 10 (For_Increment) ===============================================+
| Flags: [EMPTY]
| Statements: 0
| Predecessors (1): 9
| Successors (1): 8
+============================================================================╝

+=== Block 11 (For_Exit) ====================================================+
| Flags: [LOOP_EXIT] [EMPTY]
| Statements: 0
| Predecessors (1): 8
| Successors (1): 5
+============================================================================╝

------------------------------------------------------------------------------
DETAILED EDGE ANALYSIS
------------------------------------------------------------------------------

Edge   0: Block   0 --[JUMP]--> Block   2
Edge   1: Block   2 --[JUMP]--> Block   3
Edge   2: Block   3 --[TRUE]--> Block   4 ("true")
Edge   3: Block   3 --[TRUE]--> Block   6 ("false")
Edge   4: Block   4 --[JUMP]--> Block   7
Edge   5: Block   7 --[JUMP]--> Block   8
Edge   6: Block   8 --[TRUE]--> Block   9 ("true")
Edge   7: Block   8 --[TRUE]--> Block  11 ("false")
Edge   8: Block   9 --[JUMP]--> Block  10
Edge   9: Block  10 --[JUMP]--> Block   8 <- BACK-EDGE
Edge  10: Block  11 --[JUMP]--> Block   5 <- BACK-EDGE
Edge  11: Block   5 --[JUMP]--> Block   3 <- BACK-EDGE
Edge  12: Block   6 --[JUMP]--> Block   1 <- BACK-EDGE

------------------------------------------------------------------------------
CONTROL FLOW ANALYSIS
------------------------------------------------------------------------------

✓ All non-exit blocks are reachable from entry

DETECTED LOOPS (back-edges):
  - Block 10 → Block 8
  - Block 11 → Block 5
  - Block 5 → Block 3
  - Block 6 → Block 1

DECISION POINTS (blocks with multiple successors): 2
  - Block 3 (For_Header) → 2 paths
  - Block 8 (For_Header) → 2 paths

JOIN POINTS (blocks with multiple predecessors): 2
  - Block 3 (For_Header) ← 2 paths
  - Block 8 (For_Header) ← 2 paths

==============================================================================
END OF CFG ANALYSIS REPORT
==============================================================================


+==========================================================================+
|                       CFG ANALYSIS REPORT                                 |
+==========================================================================╝

Phase: Ack
Function: Ack
Parameters: 2 (m, n)
Return Type: INTEGER

------------------------------------------------------------------------------
SUMMARY METRICS
------------------------------------------------------------------------------
  Basic Statistics:
    Total Blocks:          8
    Total Edges:           9
    Entry Block:           0
    Exit Block:            1
    Total Statements:      8
    Reachable Blocks:      8
    Unreachable:           0
    Cyclomatic Complexity: 3 (LOW)

  Block Categories:
    Empty Blocks:          3
    Loop Headers:          0
    Loop Exits:            0
    Terminated:            0
    Multi-Pred:            2
    Multi-Succ:            2

  Edge Types:
    Conditional True:      4
    Jump:                  5

------------------------------------------------------------------------------
COMPACT FORMAT (for test validation)
------------------------------------------------------------------------------
CFG:Ack:B8:E9:S8:CC3:R8
EDGES: 0->2 0->3 2->4 3->5 3->6 5->7 6->7 7->4 4->1

==============================================================================
DETAILED BLOCK ANALYSIS
==============================================================================

+=== Block 0 (Entry) =======================================================+
| Flags: [ENTRY]
| Statements: 2
|   Types: IfStatement, LocalStatement
|   Detail:
|     [ 0] LocalStatement
|     [ 1] IfStatement
| Predecessors (0): none
| Successors (2): 2, 3
+============================================================================╝

+=== Block 1 (Exit) ========================================================+
| Flags: [EXIT] [EMPTY]
| Statements: 0
| Predecessors (1): 4
| Successors (0): none
+============================================================================╝

+=== Block 2 (If_Then) =====================================================+
| Flags: [NORMAL]
| Statements: 1
|   Types: LetStatement
|   Detail:
|     [ 0] LetStatement
| Predecessors (1): 0
| Successors (1): 4
+============================================================================╝

+=== Block 3 (If_Else) =====================================================+
| Flags: [NORMAL]
| Statements: 1
|   Types: IfStatement
|   Detail:
|     [ 0] IfStatement
| Predecessors (1): 0
| Successors (2): 5, 6
+============================================================================╝

+=== Block 4 (If_Merge) ====================================================+
| Flags: [EMPTY]
| Statements: 0
| Predecessors (2): 2, 7
| Successors (1): 1
+============================================================================╝

+=== Block 5 (If_Then) =====================================================+
| Flags: [NORMAL]
| Statements: 2
|   Types: LetStatement×2
|   Detail:
|     [ 0] LetStatement
|     [ 1] LetStatement
| Predecessors (1): 3
| Successors (1): 7
+============================================================================╝

+=== Block 6 (If_Else) =====================================================+
| Flags: [NORMAL]
| Statements: 2
|   Types: LetStatement×2
|   Detail:
|     [ 0] LetStatement
|     [ 1] LetStatement
| Predecessors (1): 3
| Successors (1): 7
+============================================================================╝

+=== Block 7 (If_Merge) ====================================================+
| Flags: [EMPTY]
| Statements: 0
| Predecessors (2): 5, 6
| Successors (1): 4
+============================================================================╝

------------------------------------------------------------------------------
DETAILED EDGE ANALYSIS
------------------------------------------------------------------------------

Edge   0: Block   0 --[TRUE]--> Block   2 ("true")
Edge   1: Block   0 --[TRUE]--> Block   3 ("false")
Edge   2: Block   2 --[JUMP]--> Block   4
Edge   3: Block   3 --[TRUE]--> Block   5 ("true")
Edge   4: Block   3 --[TRUE]--> Block   6 ("false")
Edge   5: Block   5 --[JUMP]--> Block   7
Edge   6: Block   6 --[JUMP]--> Block   7
Edge   7: Block   7 --[JUMP]--> Block   4 <- BACK-EDGE
Edge   8: Block   4 --[JUMP]--> Block   1 <- BACK-EDGE

------------------------------------------------------------------------------
CONTROL FLOW ANALYSIS
------------------------------------------------------------------------------

✓ All non-exit blocks are reachable from entry

DETECTED LOOPS (back-edges):
  - Block 7 → Block 4
  - Block 4 → Block 1

DECISION POINTS (blocks with multiple successors): 2
  - Block 0 (Entry) → 2 paths
  - Block 3 (If_Else) → 2 paths

JOIN POINTS (blocks with multiple predecessors): 2
  - Block 4 (If_Merge) ← 2 paths
  - Block 7 (If_Merge) ← 2 paths

==============================================================================
END OF CFG ANALYSIS REPORT
==============================================================================


========================================
CODE GENERATION: DISABLED
========================================
The new CFG builder generates correct control flow graphs.
Code generation will be re-enabled after adapting the
QBE code generator to work with the new CFG structure.

To test CFG generation:
  ./qbe_basic -G program.bas

========================================

[DEBUG] compile_basic_to_il: Returned from wrapper
[DEBUG] compile_basic_to_il: qbe_il is valid
[DEBUG] compile_basic_to_il: len = 0
[DEBUG] compile_basic_to_il: About to call fmemopen...
[DEBUG] compile_basic_to_il: fmemopen returned
[DEBUG] compile_basic_to_il: fmemopen failed, freeing and returning NULL
failed to compile BASIC file 'tests/rosetta//ackermann.bas'
